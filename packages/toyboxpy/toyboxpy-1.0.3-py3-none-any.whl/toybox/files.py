# SPDX-FileCopyrightText: 2022-present Paths.py Contributors
#
# SPDX-License-Identifier: MIT

import os
import shutil
import stat

from typing import List

from .boxfile import Boxfile
from .dependency import Dependency
from .paths import Paths
from .utils import Utils


class Files:
    """Methods to generate and test various files for toyboxpy."""

    @classmethod
    def findMakefileIn(cls, folder: str, repo_name: str) -> str:
        potential_names = [repo_name + '.mk',
                           'Makefile',
                           'Makefile.mk']
        for name in potential_names:
            path = os.path.join(folder, name)
            if os.path.exists(path):
                return name

        return None

    @classmethod
    def findIncludeFileIn(cls, folder: str, repo_name: str) -> str:
        potential_names = [os.path.join(repo_name, repo_name + '.h'),
                           os.path.join(repo_name, 'include.h')]
        for name in potential_names:
            path = os.path.join(folder, name)
            if os.path.exists(path):
                return name

        return None

    @classmethod
    def findLuaIncludeFileIn(cls, folder: str, repo_name: str, maybe_additional_path: str) -> str:
        if maybe_additional_path is not None:
            filename = maybe_additional_path + '.lua'
            paths_found = Utils.lookInFolderFor(folder, filename)
            if len(paths_found) != 0:
                return maybe_additional_path

            print('Warning: Could not find file \'' + filename + '\' to import in \'' + repo_name + '\'.')

        paths_found = Utils.lookInFolderFor(folder, '**/import.lua')
        paths_found += Utils.lookInFolderFor(folder, '**/' + repo_name + '.lua')

        correct_names = [repo_name,
                         'import',
                         os.path.join('Source', repo_name),
                         os.path.join('Source', 'import'),
                         os.path.join('source', repo_name),
                         os.path.join('source', 'import')]

        for path_found in paths_found:
            for correct_name in correct_names:
                if path_found == correct_name:
                    return path_found

        return None

    @classmethod
    def generateLuaIncludeFile(cls, dependencies: List[Dependency]):
        lua_includes = []

        for dep in dependencies:
            dep_folder = Paths.toyboxFolderFor(dep)

            maybe_lua_include_path = Boxfile(dep_folder).maybeLuaImportFile()
            if maybe_lua_include_path is not None and maybe_lua_include_path.endswith('.lua'):
                maybe_lua_include_path = maybe_lua_include_path[:-4]

            lua_include_path = Files.findLuaIncludeFileIn(dep_folder, dep.url.repo_name, maybe_lua_include_path)

            if lua_include_path is not None:
                lua_includes.append(os.path.join(dep.subFolder(), lua_include_path))

        if len(lua_includes) == 0:
            return

        with open(os.path.join(Paths.toyboxesFolder(), 'toyboxes.lua'), 'w') as out_file:
            out_file.write('--\n')
            out_file.write('--  toyboxes.lua - include file auto-generated by toybox.py (https://toyboxpy.io).\n')
            out_file.write('--\n')
            out_file.write('\n')

            for lua_include in lua_includes:
                out_file.write('import \'' + lua_include + '.lua\'\n')

            out_file.close()

    @classmethod
    def generateMakefile(cls, dependencies: List[Dependency]):
        makefiles = []

        for dep in dependencies:
            dep_folder = Paths.toyboxFolderFor(dep)
            makefile_path = Files.findMakefileIn(dep_folder, dep.url.repo_name)
            if makefile_path is not None:
                makefiles.append([os.path.join(dep.subFolder(), makefile_path), dep.url.repo_name.upper()])

        if len(makefiles) == 0:
            return

        with open(os.path.join(Paths.toyboxesFolder(), 'toyboxes.mk'), 'w') as out_file:
            out_file.write('#\n')
            out_file.write('#  toyboxes.mk - include file auto-generated by toybox.py (https://toyboxpy.io).\n')
            out_file.write('#\n')
            out_file.write('\n')
            out_file.write('_RELATIVE_FILE_PATH := $(lastword $(MAKEFILE_LIST))\n')
            out_file.write('_RELATIVE_DIR := $(subst /$(notdir $(_RELATIVE_FILE_PATH)),,$(_RELATIVE_FILE_PATH))\n')
            out_file.write('\n')
            out_file.write('uniq = $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1)))\n')
            out_file.write('UINCDIR := $(call uniq, $(UINCDIR) $(_RELATIVE_DIR))\n')
            out_file.write('\n')

            for makefile in makefiles:
                out_file.write(makefile[1] + '_MAKEFILE := $(_RELATIVE_DIR)/' + makefile[0] + '\n')

            out_file.write('\n')

            for makefile in makefiles:
                out_file.write('include $(' + makefile[1] + '_MAKEFILE)\n')

            out_file.close()

    @classmethod
    def generateIncludeFile(cls, dependencies: List[Dependency]):
        include_files = []

        for dep in dependencies:
            dep_folder = Paths.toyboxFolderFor(dep)
            include_file_path = Files.findIncludeFileIn(dep_folder, dep.url.repo_name)
            if include_file_path is not None:
                include_files.append([os.path.join(dep.subFolder(), include_file_path), dep.url.repo_name])

        if len(include_files) == 0:
            return

        with open(os.path.join(Paths.toyboxesFolder(), 'toyboxes.h'), 'w') as out_file:
            out_file.write('//\n')
            out_file.write('//  toyboxes.h - include file auto-generated by toybox.py (https://toyboxpy.io).\n')
            out_file.write('//\n')
            out_file.write('\n')

            for include in include_files:
                out_file.write('#include "' + include[0] + '"\n')

            out_file.write('\n')

            prefix = ''
            out_file.write('#define REGISTER_TOYBOXES(pd)')
            for include in include_files:
                out_file.write(prefix + '   register_' + include[1] + '(pd);')
                prefix = ' \\\n                             '

            out_file.write('\n')

            out_file.close()

    @classmethod
    def generateReadMeFileIn(cls, folder: str):
        with open(os.path.join(folder, 'README.md'), 'w') as out_file:
            out_file.write('# ' + os.path.basename(folder) + '\n')
            out_file.write('\n')
            out_file.write('This folder contains files auto-generated and managed by [**toybox.py**](https://toyboxpy.io).\n')
            out_file.write('\n')
            out_file.write('**!!! DO NOT MODIFY OR PLACE ANYTHING IN THIS FOLDER !!!**\n')
            out_file.write('\n')
            out_file.write('Please [install](https://github.com/toyboxpy/toybox.py#installing) **toybox.py** in order to modify or update the content of this folder.\n')

    @classmethod
    def generatePreCommitFile(cls):
        if not os.path.exists('.git'):
            return

        pre_commit_file_path = Paths.preCommitFilePath()
        if os.path.exists(pre_commit_file_path):
            shutil.move(pre_commit_file_path, Paths.preCommitFilePathBackup())
        else:
            with open(Paths.preCommitFileNoBackupPath(), 'w') as out_file:
                out_file.write('#!/bin/sh\n')
                out_file.write('#\n')
                out_file.write('# This file is generated by toybox.py to remember there was no backup to be restored.\n')
                out_file.write('\n')

        with open(pre_commit_file_path, 'w') as out_file:
            out_file.write('#!/bin/sh\n')
            out_file.write('#\n')
            out_file.write('# This file is generated by toybox.py to prevent committing local toyboxes.\n')
            out_file.write('\n')
            out_file.write('echo "You shouldn\'t commit when you have \'local\' toyboxes in your repo."\n')
            out_file.write('exit 1\n')

        if os.path.exists(pre_commit_file_path):
            os.chmod(pre_commit_file_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)

    @classmethod
    def restorePreCommitFileIfAny(cls):
        if not os.path.exists('.git'):
            return

        pre_commit_file_path = Paths.preCommitFilePath()
        pre_commit_file_backup_path = Paths.preCommitFileBackupPath()
        pre_commit_file_no_backup_path = Paths.preCommitFileNoBackupPath()

        if os.path.exists(pre_commit_file_no_backup_path):
            os.remove(pre_commit_file_no_backup_path)
            os.remove(pre_commit_file_path)
        elif os.path.exists(pre_commit_file_backup_path):
            os.remove(pre_commit_file_path)
            shutil.move(pre_commit_file_backup_path, pre_commit_file_path)
