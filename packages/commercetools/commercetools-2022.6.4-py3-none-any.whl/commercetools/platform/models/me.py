# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .business_unit import BusinessUnitType
from .cart import InventoryMode, TaxMode
from .payment import TransactionType

if typing.TYPE_CHECKING:
    from .business_unit import (
        AssociateDraft,
        BusinessUnitKeyReference,
        BusinessUnitResourceIdentifier,
        BusinessUnitType,
        BusinessUnitUpdateAction,
    )
    from .cart import (
        CartReference,
        CartResourceIdentifier,
        ExternalLineItemTotalPrice,
        ExternalTaxRateDraft,
        InventoryMode,
        ItemShippingDetailsDraft,
        ItemShippingTarget,
        TaxMode,
    )
    from .channel import ChannelResourceIdentifier
    from .common import BaseAddress, LocalizedString, Money, TypedMoney
    from .customer import CustomerReference, CustomerResourceIdentifier
    from .discount_code import DiscountCodeReference
    from .order import OrderReference
    from .payment import (
        PaymentMethodInfo,
        PaymentResourceIdentifier,
        Transaction,
        TransactionDraft,
        TransactionType,
    )
    from .shipping_method import ShippingMethodResourceIdentifier
    from .shopping_list import ShoppingListLineItemDraft, TextLineItemDraft
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "MyBusinessUnitAddAddressAction",
    "MyBusinessUnitAddBillingAddressIdAction",
    "MyBusinessUnitAddShippingAddressIdAction",
    "MyBusinessUnitAssociateDraft",
    "MyBusinessUnitChangeAddressAction",
    "MyBusinessUnitChangeAssociateAction",
    "MyBusinessUnitChangeNameAction",
    "MyBusinessUnitChangeParentUnitAction",
    "MyBusinessUnitDraft",
    "MyBusinessUnitRemoveAddressAction",
    "MyBusinessUnitRemoveAssociateAction",
    "MyBusinessUnitRemoveBillingAddressIdAction",
    "MyBusinessUnitRemoveShippingAddressIdAction",
    "MyBusinessUnitSetAddressCustomFieldAction",
    "MyBusinessUnitSetAddressCustomTypeAction",
    "MyBusinessUnitSetContactEmailAction",
    "MyBusinessUnitSetCustomFieldAction",
    "MyBusinessUnitSetCustomTypeAction",
    "MyBusinessUnitSetDefaultBillingAddressAction",
    "MyBusinessUnitSetDefaultShippingAddressAction",
    "MyBusinessUnitUpdate",
    "MyBusinessUnitUpdateAction",
    "MyCartAddDiscountCodeAction",
    "MyCartAddItemShippingAddressAction",
    "MyCartAddLineItemAction",
    "MyCartAddPaymentAction",
    "MyCartApplyDeltaToLineItemShippingDetailsTargetsAction",
    "MyCartChangeLineItemQuantityAction",
    "MyCartChangeTaxModeAction",
    "MyCartDraft",
    "MyCartRecalculateAction",
    "MyCartRemoveDiscountCodeAction",
    "MyCartRemoveItemShippingAddressAction",
    "MyCartRemoveLineItemAction",
    "MyCartRemovePaymentAction",
    "MyCartSetBillingAddressAction",
    "MyCartSetCountryAction",
    "MyCartSetCustomFieldAction",
    "MyCartSetCustomTypeAction",
    "MyCartSetCustomerEmailAction",
    "MyCartSetDeleteDaysAfterLastModificationAction",
    "MyCartSetLineItemCustomFieldAction",
    "MyCartSetLineItemCustomTypeAction",
    "MyCartSetLineItemDistributionChannelAction",
    "MyCartSetLineItemShippingDetailsAction",
    "MyCartSetLineItemSupplyChannelAction",
    "MyCartSetLocaleAction",
    "MyCartSetShippingAddressAction",
    "MyCartSetShippingMethodAction",
    "MyCartUpdate",
    "MyCartUpdateAction",
    "MyCartUpdateItemShippingAddressAction",
    "MyCompanyDraft",
    "MyCustomerAddAddressAction",
    "MyCustomerAddBillingAddressIdAction",
    "MyCustomerAddShippingAddressIdAction",
    "MyCustomerChangeAddressAction",
    "MyCustomerChangeEmailAction",
    "MyCustomerDraft",
    "MyCustomerRemoveAddressAction",
    "MyCustomerRemoveBillingAddressIdAction",
    "MyCustomerRemoveShippingAddressIdAction",
    "MyCustomerSetCompanyNameAction",
    "MyCustomerSetCustomFieldAction",
    "MyCustomerSetCustomTypeAction",
    "MyCustomerSetDateOfBirthAction",
    "MyCustomerSetDefaultBillingAddressAction",
    "MyCustomerSetDefaultShippingAddressAction",
    "MyCustomerSetFirstNameAction",
    "MyCustomerSetLastNameAction",
    "MyCustomerSetLocaleAction",
    "MyCustomerSetMiddleNameAction",
    "MyCustomerSetSalutationAction",
    "MyCustomerSetTitleAction",
    "MyCustomerSetVatIdAction",
    "MyCustomerUpdate",
    "MyCustomerUpdateAction",
    "MyDivisionDraft",
    "MyLineItemDraft",
    "MyOrderFromCartDraft",
    "MyPayment",
    "MyPaymentAddTransactionAction",
    "MyPaymentChangeAmountPlannedAction",
    "MyPaymentDraft",
    "MyPaymentPagedQueryResponse",
    "MyPaymentSetCustomFieldAction",
    "MyPaymentSetMethodInfoInterfaceAction",
    "MyPaymentSetMethodInfoMethodAction",
    "MyPaymentSetMethodInfoNameAction",
    "MyPaymentSetTransactionCustomFieldAction",
    "MyPaymentUpdate",
    "MyPaymentUpdateAction",
    "MyQuoteChangeMyQuoteStateAction",
    "MyQuoteRequestCancelAction",
    "MyQuoteRequestDraft",
    "MyQuoteRequestUpdate",
    "MyQuoteRequestUpdateAction",
    "MyQuoteState",
    "MyQuoteUpdate",
    "MyQuoteUpdateAction",
    "MyShoppingListAddLineItemAction",
    "MyShoppingListAddTextLineItemAction",
    "MyShoppingListChangeLineItemQuantityAction",
    "MyShoppingListChangeLineItemsOrderAction",
    "MyShoppingListChangeNameAction",
    "MyShoppingListChangeTextLineItemNameAction",
    "MyShoppingListChangeTextLineItemQuantityAction",
    "MyShoppingListChangeTextLineItemsOrderAction",
    "MyShoppingListDraft",
    "MyShoppingListRemoveLineItemAction",
    "MyShoppingListRemoveTextLineItemAction",
    "MyShoppingListSetCustomFieldAction",
    "MyShoppingListSetCustomTypeAction",
    "MyShoppingListSetDeleteDaysAfterLastModificationAction",
    "MyShoppingListSetDescriptionAction",
    "MyShoppingListSetLineItemCustomFieldAction",
    "MyShoppingListSetLineItemCustomTypeAction",
    "MyShoppingListSetTextLineItemCustomFieldAction",
    "MyShoppingListSetTextLineItemCustomTypeAction",
    "MyShoppingListSetTextLineItemDescriptionAction",
    "MyShoppingListUpdate",
    "MyShoppingListUpdateAction",
    "MyTransactionDraft",
    "ReplicaMyCartDraft",
]


class MyBusinessUnitAssociateDraft(_BaseType):
    #: Expected version of the BusinessUnit on which the changes should be applied. If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) error will be returned.
    version: int
    #: [Customer](ctp:api:type:Customer) to create and assign to the Business Unit.
    customer: "MyCustomerDraft"

    def __init__(self, *, version: int, customer: "MyCustomerDraft"):
        self.version = version
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAssociateDraft":
        from ._schemas.me import MyBusinessUnitAssociateDraftSchema

        return MyBusinessUnitAssociateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAssociateDraftSchema

        return MyBusinessUnitAssociateDraftSchema().dump(self)


class MyBusinessUnitDraft(_BaseType):
    #: User-defined unique identifier for the BusinessUnit.
    key: str
    #: Type of the Business Unit indicating its position in a hierarchy.
    unit_type: "BusinessUnitType"
    #: Name of the Business Unit.
    name: str
    #: Email address of the Business Unit.
    contact_email: typing.Optional[str]
    #: Custom Fields for the Business Unit.
    custom: typing.Optional["CustomFields"]
    #: Addresses used by the Business Unit.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Indexes of entries in `addresses` to set as shipping addresses.
    #: The `shippingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    shipping_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default shipping address.
    default_shiping_address: typing.Optional[int]
    #: Indexes of entries in `addresses` to set as billing addresses.
    #: The `billingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    billing_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default billing address.
    default_billing_address: typing.Optional[int]

    def __init__(
        self,
        *,
        key: str,
        unit_type: "BusinessUnitType",
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shiping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None
    ):
        self.key = key
        self.unit_type = unit_type
        self.name = name
        self.contact_email = contact_email
        self.custom = custom
        self.addresses = addresses
        self.shipping_addresses = shipping_addresses
        self.default_shiping_address = default_shiping_address
        self.billing_addresses = billing_addresses
        self.default_billing_address = default_billing_address

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyBusinessUnitDraft":
        if data["unitType"] == "Company":
            from ._schemas.me import MyCompanyDraftSchema

            return MyCompanyDraftSchema().load(data)
        if data["unitType"] == "Division":
            from ._schemas.me import MyDivisionDraftSchema

            return MyDivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitDraftSchema

        return MyBusinessUnitDraftSchema().dump(self)


class MyBusinessUnitUpdate(_BaseType):
    #: Expected version of the BusinessUnit on which the changes should be applied.
    #: If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) error will be returned.
    version: int
    #: Update actions to be performed on the BusinessUnit.
    actions: typing.List["BusinessUnitUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["BusinessUnitUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyBusinessUnitUpdate":
        from ._schemas.me import MyBusinessUnitUpdateSchema

        return MyBusinessUnitUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitUpdateSchema

        return MyBusinessUnitUpdateSchema().dump(self)


class MyBusinessUnitUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.me import MyBusinessUnitAddAddressActionSchema

            return MyBusinessUnitAddAddressActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

            return MyBusinessUnitAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

            return MyBusinessUnitAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

            return MyBusinessUnitChangeAddressActionSchema().load(data)
        if data["action"] == "changeAssociate":
            from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

            return MyBusinessUnitChangeAssociateActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.me import MyBusinessUnitChangeNameActionSchema

            return MyBusinessUnitChangeNameActionSchema().load(data)
        if data["action"] == "changeParentUnit":
            from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

            return MyBusinessUnitChangeParentUnitActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

            return MyBusinessUnitRemoveAddressActionSchema().load(data)
        if data["action"] == "removeAssociate":
            from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

            return MyBusinessUnitRemoveAssociateActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

            return MyBusinessUnitRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

            return MyBusinessUnitRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "setAddressCustomField":
            from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

            return MyBusinessUnitSetAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setAddressCustomType":
            from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

            return MyBusinessUnitSetAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setContactEmail":
            from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

            return MyBusinessUnitSetContactEmailActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

            return MyBusinessUnitSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

            return MyBusinessUnitSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

            return MyBusinessUnitSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

            return MyBusinessUnitSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitUpdateActionSchema

        return MyBusinessUnitUpdateActionSchema().dump(self)


class MyCartDraft(_BaseType):
    #: A three-digit currency code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    currency: str
    customer_email: typing.Optional[str]
    #: A two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    country: typing.Optional[str]
    #: Default inventory mode is `None`.
    inventory_mode: typing.Optional["InventoryMode"]
    line_items: typing.Optional[typing.List["MyLineItemDraft"]]
    shipping_address: typing.Optional["BaseAddress"]
    billing_address: typing.Optional["BaseAddress"]
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: The custom fields.
    custom: typing.Optional["CustomFieldsDraft"]
    locale: typing.Optional[str]
    #: The `TaxMode` `Disabled` can not be set on the My Carts endpoint.
    tax_mode: typing.Optional["TaxMode"]
    #: The cart will be deleted automatically if it hasn't been modified for the specified amount of days and it is in the `Active` CartState.
    #: If a ChangeSubscription for carts exists, a `ResourceDeleted` notification will be sent.
    delete_days_after_last_modification: typing.Optional[int]
    #: Contains addresses for orders with multiple shipping addresses.
    #: Each address must contain a key which is unique in this cart.
    item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]]
    #: The BusinessUnit the cart will belong to.
    business_unit: typing.Optional["BusinessUnitKeyReference"]
    #: [Reference](/../api/types#reference) to a [Store](ctp:api:type:Store) by its key.
    store: typing.Optional["StoreKeyReference"]
    #: The code of existing DiscountCodes.
    discount_codes: typing.Optional[typing.List["str"]]

    def __init__(
        self,
        *,
        currency: str,
        customer_email: typing.Optional[str] = None,
        country: typing.Optional[str] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        line_items: typing.Optional[typing.List["MyLineItemDraft"]] = None,
        shipping_address: typing.Optional["BaseAddress"] = None,
        billing_address: typing.Optional["BaseAddress"] = None,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        locale: typing.Optional[str] = None,
        tax_mode: typing.Optional["TaxMode"] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        business_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        store: typing.Optional["StoreKeyReference"] = None,
        discount_codes: typing.Optional[typing.List["str"]] = None
    ):
        self.currency = currency
        self.customer_email = customer_email
        self.country = country
        self.inventory_mode = inventory_mode
        self.line_items = line_items
        self.shipping_address = shipping_address
        self.billing_address = billing_address
        self.shipping_method = shipping_method
        self.custom = custom
        self.locale = locale
        self.tax_mode = tax_mode
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.item_shipping_addresses = item_shipping_addresses
        self.business_unit = business_unit
        self.store = store
        self.discount_codes = discount_codes

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartDraft":
        from ._schemas.me import MyCartDraftSchema

        return MyCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartDraftSchema

        return MyCartDraftSchema().dump(self)


class MyCartUpdate(_BaseType):
    version: int
    actions: typing.List["MyCartUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyCartUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartUpdate":
        from ._schemas.me import MyCartUpdateSchema

        return MyCartUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateSchema

        return MyCartUpdateSchema().dump(self)


class MyCartUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartUpdateAction":
        if data["action"] == "addDiscountCode":
            from ._schemas.me import MyCartAddDiscountCodeActionSchema

            return MyCartAddDiscountCodeActionSchema().load(data)
        if data["action"] == "addItemShippingAddress":
            from ._schemas.me import MyCartAddItemShippingAddressActionSchema

            return MyCartAddItemShippingAddressActionSchema().load(data)
        if data["action"] == "addLineItem":
            from ._schemas.me import MyCartAddLineItemActionSchema

            return MyCartAddLineItemActionSchema().load(data)
        if data["action"] == "addPayment":
            from ._schemas.me import MyCartAddPaymentActionSchema

            return MyCartAddPaymentActionSchema().load(data)
        if data["action"] == "applyDeltaToLineItemShippingDetailsTargets":
            from ._schemas.me import (
                MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
            )

            return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(
                data
            )
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

            return MyCartChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTaxMode":
            from ._schemas.me import MyCartChangeTaxModeActionSchema

            return MyCartChangeTaxModeActionSchema().load(data)
        if data["action"] == "recalculate":
            from ._schemas.me import MyCartRecalculateActionSchema

            return MyCartRecalculateActionSchema().load(data)
        if data["action"] == "removeDiscountCode":
            from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

            return MyCartRemoveDiscountCodeActionSchema().load(data)
        if data["action"] == "removeItemShippingAddress":
            from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

            return MyCartRemoveItemShippingAddressActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.me import MyCartRemoveLineItemActionSchema

            return MyCartRemoveLineItemActionSchema().load(data)
        if data["action"] == "removePayment":
            from ._schemas.me import MyCartRemovePaymentActionSchema

            return MyCartRemovePaymentActionSchema().load(data)
        if data["action"] == "setBillingAddress":
            from ._schemas.me import MyCartSetBillingAddressActionSchema

            return MyCartSetBillingAddressActionSchema().load(data)
        if data["action"] == "setCountry":
            from ._schemas.me import MyCartSetCountryActionSchema

            return MyCartSetCountryActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyCartSetCustomFieldActionSchema

            return MyCartSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyCartSetCustomTypeActionSchema

            return MyCartSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerEmail":
            from ._schemas.me import MyCartSetCustomerEmailActionSchema

            return MyCartSetCustomerEmailActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.me import (
                MyCartSetDeleteDaysAfterLastModificationActionSchema,
            )

            return MyCartSetDeleteDaysAfterLastModificationActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

            return MyCartSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

            return MyCartSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemDistributionChannel":
            from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

            return MyCartSetLineItemDistributionChannelActionSchema().load(data)
        if data["action"] == "setLineItemShippingDetails":
            from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

            return MyCartSetLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setLineItemSupplyChannel":
            from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

            return MyCartSetLineItemSupplyChannelActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.me import MyCartSetLocaleActionSchema

            return MyCartSetLocaleActionSchema().load(data)
        if data["action"] == "setShippingAddress":
            from ._schemas.me import MyCartSetShippingAddressActionSchema

            return MyCartSetShippingAddressActionSchema().load(data)
        if data["action"] == "setShippingMethod":
            from ._schemas.me import MyCartSetShippingMethodActionSchema

            return MyCartSetShippingMethodActionSchema().load(data)
        if data["action"] == "updateItemShippingAddress":
            from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

            return MyCartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateActionSchema

        return MyCartUpdateActionSchema().dump(self)


class MyCompanyDraft(MyBusinessUnitDraft):
    """Draft type to represent the top level of a business.
    Contains the fields and values of the generic [MyBusinessUnitDraft](ctp:api:type:BusinessUnitDraft) that are used specifically for creating a [Company](ctp:api:type:Company).

    """

    def __init__(
        self,
        *,
        key: str,
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shiping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None
    ):

        super().__init__(
            key=key,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shiping_address=default_shiping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            unit_type=BusinessUnitType.COMPANY,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCompanyDraft":
        from ._schemas.me import MyCompanyDraftSchema

        return MyCompanyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCompanyDraftSchema

        return MyCompanyDraftSchema().dump(self)


class MyCustomerDraft(_BaseType):
    #: Email address of the Customer that is [unique](/../api/customers-overview#customer-uniqueness) for an entire Project or Store the Customer is assigned to.
    #: It is the mandatory unique identifier of a Customer.
    email: str
    #: Password of the Customer.
    password: str
    #: Given name (first name) of the Customer.
    first_name: typing.Optional[str]
    #: Family name (last name) of the Customer.
    last_name: typing.Optional[str]
    #: Middle name of the Customer.
    middle_name: typing.Optional[str]
    #: Title of the Customer, for example, 'Dr.'.
    title: typing.Optional[str]
    #: Salutation of the Customer, for example, 'Mr.' or 'Mrs.'.
    salutation: typing.Optional[str]
    #: Date of birth of the Customer.
    date_of_birth: typing.Optional[datetime.date]
    #: Company name of the Customer.
    company_name: typing.Optional[str]
    #: Unique VAT ID of the Customer.
    vat_id: typing.Optional[str]
    #: Addresses of the Customer.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Index of the address in the `addresses` array to use as the default shipping address.
    #: The `defaultShippingAddressId` of the Customer will be set to the `id` of that address.
    default_shipping_address: typing.Optional[int]
    #: Index of the address in the `addresses` array to use as the default billing address.
    #: The `defaultBillingAddressId` of the Customer will be set to the `id` of that address.
    default_billing_address: typing.Optional[int]
    #: Custom Fields for the Customer.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Preferred language of the Customer. Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Sets the [Stores](ctp:api:type:Store) for the Customer.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self,
        *,
        email: str,
        password: str,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        middle_name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        date_of_birth: typing.Optional[datetime.date] = None,
        company_name: typing.Optional[str] = None,
        vat_id: typing.Optional[str] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        default_billing_address: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        locale: typing.Optional[str] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.email = email
        self.password = password
        self.first_name = first_name
        self.last_name = last_name
        self.middle_name = middle_name
        self.title = title
        self.salutation = salutation
        self.date_of_birth = date_of_birth
        self.company_name = company_name
        self.vat_id = vat_id
        self.addresses = addresses
        self.default_shipping_address = default_shipping_address
        self.default_billing_address = default_billing_address
        self.custom = custom
        self.locale = locale
        self.stores = stores

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerDraft":
        from ._schemas.me import MyCustomerDraftSchema

        return MyCustomerDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerDraftSchema

        return MyCustomerDraftSchema().dump(self)


class MyCustomerUpdate(_BaseType):
    #: Expected version of the Customer on which the changes should be applied. If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) error will be returned.
    version: int
    #: Update actions to be performed on the Customer.
    actions: typing.List["MyCustomerUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyCustomerUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerUpdate":
        from ._schemas.me import MyCustomerUpdateSchema

        return MyCustomerUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerUpdateSchema

        return MyCustomerUpdateSchema().dump(self)


class MyCustomerUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.me import MyCustomerAddAddressActionSchema

            return MyCustomerAddAddressActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

            return MyCustomerAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

            return MyCustomerAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.me import MyCustomerChangeAddressActionSchema

            return MyCustomerChangeAddressActionSchema().load(data)
        if data["action"] == "changeEmail":
            from ._schemas.me import MyCustomerChangeEmailActionSchema

            return MyCustomerChangeEmailActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.me import MyCustomerRemoveAddressActionSchema

            return MyCustomerRemoveAddressActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

            return MyCustomerRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

            return MyCustomerRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "setCompanyName":
            from ._schemas.me import MyCustomerSetCompanyNameActionSchema

            return MyCustomerSetCompanyNameActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyCustomerSetCustomFieldActionSchema

            return MyCustomerSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyCustomerSetCustomTypeActionSchema

            return MyCustomerSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDateOfBirth":
            from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

            return MyCustomerSetDateOfBirthActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

            return MyCustomerSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

            return MyCustomerSetDefaultShippingAddressActionSchema().load(data)
        if data["action"] == "setFirstName":
            from ._schemas.me import MyCustomerSetFirstNameActionSchema

            return MyCustomerSetFirstNameActionSchema().load(data)
        if data["action"] == "setLastName":
            from ._schemas.me import MyCustomerSetLastNameActionSchema

            return MyCustomerSetLastNameActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.me import MyCustomerSetLocaleActionSchema

            return MyCustomerSetLocaleActionSchema().load(data)
        if data["action"] == "setMiddleName":
            from ._schemas.me import MyCustomerSetMiddleNameActionSchema

            return MyCustomerSetMiddleNameActionSchema().load(data)
        if data["action"] == "setSalutation":
            from ._schemas.me import MyCustomerSetSalutationActionSchema

            return MyCustomerSetSalutationActionSchema().load(data)
        if data["action"] == "setTitle":
            from ._schemas.me import MyCustomerSetTitleActionSchema

            return MyCustomerSetTitleActionSchema().load(data)
        if data["action"] == "setVatId":
            from ._schemas.me import MyCustomerSetVatIdActionSchema

            return MyCustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerUpdateActionSchema

        return MyCustomerUpdateActionSchema().dump(self)


class MyDivisionDraft(MyBusinessUnitDraft):
    """Draft type to model divisions that are part of the [Company](ctp:api:type:Company) or a higher order [Division](ctp:api:type:Division).
    Contains the fields and values of the generic [MyBusinessUnitDraft](ctp:api:type:MyBusinessUnitDraft) that are used specifically for creating a Division.

    """

    #: The parent unit of this Division. Can be a Company or a Division.
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(
        self,
        *,
        key: str,
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shiping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        parent_unit: "BusinessUnitResourceIdentifier"
    ):
        self.parent_unit = parent_unit

        super().__init__(
            key=key,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shiping_address=default_shiping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            unit_type=BusinessUnitType.DIVISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyDivisionDraft":
        from ._schemas.me import MyDivisionDraftSchema

        return MyDivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyDivisionDraftSchema

        return MyDivisionDraftSchema().dump(self)


class MyLineItemDraft(_BaseType):
    product_id: typing.Optional[str]
    variant_id: typing.Optional[int]
    quantity: int
    #: When the line item was added to the cart. Optional for backwards
    #: compatibility reasons only.
    added_at: typing.Optional[datetime.datetime]
    #: By providing supply channel information, you can unique identify
    #: inventory entries that should be reserved.
    #: The provided channel should have the InventorySupply role.
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: The channel is used to select a ProductPrice.
    #: The provided channel should have the ProductDistribution role.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: The custom fields.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Container for line item specific address(es).
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    sku: typing.Optional[str]

    def __init__(
        self,
        *,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        quantity: int,
        added_at: typing.Optional[datetime.datetime] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        sku: typing.Optional[str] = None
    ):
        self.product_id = product_id
        self.variant_id = variant_id
        self.quantity = quantity
        self.added_at = added_at
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel
        self.custom = custom
        self.shipping_details = shipping_details
        self.sku = sku

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyLineItemDraft":
        from ._schemas.me import MyLineItemDraftSchema

        return MyLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyLineItemDraftSchema

        return MyLineItemDraftSchema().dump(self)


class MyOrderFromCartDraft(_BaseType):
    #: Unique identifier of the Cart that initiates an Order creation.
    id: str
    version: int

    def __init__(self, *, id: str, version: int):
        self.id = id
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyOrderFromCartDraft":
        from ._schemas.me import MyOrderFromCartDraftSchema

        return MyOrderFromCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyOrderFromCartDraftSchema

        return MyOrderFromCartDraftSchema().dump(self)


class MyPayment(_BaseType):
    #: Unique identifier of the MyPayment.
    id: str
    version: int
    #: A reference to the customer this payment belongs to.
    customer: typing.Optional["CustomerReference"]
    #: Identifies payments belonging to an anonymous session (the customer has not signed up/in yet).
    anonymous_id: typing.Optional[str]
    #: How much money this payment intends to receive from the customer.
    #: The value usually matches the cart or order gross total.
    amount_planned: "TypedMoney"
    payment_method_info: "PaymentMethodInfo"
    #: A list of financial transactions of different TransactionTypes
    #: with different TransactionStates.
    transactions: typing.List["Transaction"]
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        customer: typing.Optional["CustomerReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        amount_planned: "TypedMoney",
        payment_method_info: "PaymentMethodInfo",
        transactions: typing.List["Transaction"],
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.version = version
        self.customer = customer
        self.anonymous_id = anonymous_id
        self.amount_planned = amount_planned
        self.payment_method_info = payment_method_info
        self.transactions = transactions
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPayment":
        from ._schemas.me import MyPaymentSchema

        return MyPaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSchema

        return MyPaymentSchema().dump(self)


class MyPaymentDraft(_BaseType):
    #: How much money this payment intends to receive from the customer.
    #: The value usually matches the cart or order gross total.
    amount_planned: "Money"
    payment_method_info: typing.Optional["PaymentMethodInfo"]
    custom: typing.Optional["CustomFieldsDraft"]
    #: A list of financial transactions of the `Authorization` or `Charge`
    #: TransactionTypes.
    transaction: typing.Optional["MyTransactionDraft"]

    def __init__(
        self,
        *,
        amount_planned: "Money",
        payment_method_info: typing.Optional["PaymentMethodInfo"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        transaction: typing.Optional["MyTransactionDraft"] = None
    ):
        self.amount_planned = amount_planned
        self.payment_method_info = payment_method_info
        self.custom = custom
        self.transaction = transaction

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentDraft":
        from ._schemas.me import MyPaymentDraftSchema

        return MyPaymentDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentDraftSchema

        return MyPaymentDraftSchema().dump(self)


class MyPaymentPagedQueryResponse(_BaseType):
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    count: int
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    results: typing.List["MyPayment"]

    def __init__(
        self,
        *,
        limit: int,
        count: int,
        total: typing.Optional[int] = None,
        offset: int,
        results: typing.List["MyPayment"]
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentPagedQueryResponse":
        from ._schemas.me import MyPaymentPagedQueryResponseSchema

        return MyPaymentPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentPagedQueryResponseSchema

        return MyPaymentPagedQueryResponseSchema().dump(self)


class MyPaymentUpdate(_BaseType):
    version: int
    actions: typing.List["MyPaymentUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyPaymentUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentUpdate":
        from ._schemas.me import MyPaymentUpdateSchema

        return MyPaymentUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentUpdateSchema

        return MyPaymentUpdateSchema().dump(self)


class MyPaymentUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentUpdateAction":
        if data["action"] == "addTransaction":
            from ._schemas.me import MyPaymentAddTransactionActionSchema

            return MyPaymentAddTransactionActionSchema().load(data)
        if data["action"] == "changeAmountPlanned":
            from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

            return MyPaymentChangeAmountPlannedActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyPaymentSetCustomFieldActionSchema

            return MyPaymentSetCustomFieldActionSchema().load(data)
        if data["action"] == "setMethodInfoInterface":
            from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

            return MyPaymentSetMethodInfoInterfaceActionSchema().load(data)
        if data["action"] == "setMethodInfoMethod":
            from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

            return MyPaymentSetMethodInfoMethodActionSchema().load(data)
        if data["action"] == "setMethodInfoName":
            from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

            return MyPaymentSetMethodInfoNameActionSchema().load(data)
        if data["action"] == "setTransactionCustomField":
            from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

            return MyPaymentSetTransactionCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentUpdateActionSchema

        return MyPaymentUpdateActionSchema().dump(self)


class MyQuoteRequestDraft(_BaseType):
    #: ResourceIdentifier of the Cart from which the Quote Request is created.
    cart: "CartResourceIdentifier"
    #: Current version of the Cart.
    version: int
    #: Message from the Buyer included in the Quote Request.
    comment: str

    def __init__(self, *, cart: "CartResourceIdentifier", version: int, comment: str):
        self.cart = cart
        self.version = version
        self.comment = comment

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteRequestDraft":
        from ._schemas.me import MyQuoteRequestDraftSchema

        return MyQuoteRequestDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestDraftSchema

        return MyQuoteRequestDraftSchema().dump(self)


class MyQuoteRequestUpdate(_BaseType):
    version: int
    actions: typing.List["MyQuoteRequestUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["MyQuoteRequestUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteRequestUpdate":
        from ._schemas.me import MyQuoteRequestUpdateSchema

        return MyQuoteRequestUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestUpdateSchema

        return MyQuoteRequestUpdateSchema().dump(self)


class MyQuoteRequestUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteRequestUpdateAction":
        if data["action"] == "cancelQuoteRequest":
            from ._schemas.me import MyQuoteRequestCancelActionSchema

            return MyQuoteRequestCancelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestUpdateActionSchema

        return MyQuoteRequestUpdateActionSchema().dump(self)


class MyQuoteState(enum.Enum):
    """[QuoteStates](ctp:api:type:QuoteState) that can be set using the [Change My Quote State](ctp:api:type:MyQuoteChangeMyQuoteStateAction) update action."""

    DECLINED = "Declined"
    ACCEPTED = "Accepted"


class MyQuoteUpdate(_BaseType):
    #: Expected version of the [Quote](ctp:api:type:Quote) to which the changes should be applied.
    #: If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) error will be returned.
    version: int
    #: Update actions to be performed on the [Quote](ctp:api:type:Quote).
    actions: typing.List["MyQuoteUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyQuoteUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteUpdate":
        from ._schemas.me import MyQuoteUpdateSchema

        return MyQuoteUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteUpdateSchema

        return MyQuoteUpdateSchema().dump(self)


class MyQuoteUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteUpdateAction":
        if data["action"] == "changeMyQuoteState":
            from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

            return MyQuoteChangeMyQuoteStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteUpdateActionSchema

        return MyQuoteUpdateActionSchema().dump(self)


class MyShoppingListDraft(_BaseType):
    name: "LocalizedString"
    description: typing.Optional["LocalizedString"]
    line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]]
    text_line_items: typing.Optional[typing.List["TextLineItemDraft"]]
    #: The custom fields.
    custom: typing.Optional["CustomFieldsDraft"]
    #: The shopping list will be deleted automatically if it hasn't been modified for the specified amount of days.
    delete_days_after_last_modification: typing.Optional[int]
    store: typing.Optional["StoreResourceIdentifier"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]] = None,
        text_line_items: typing.Optional[typing.List["TextLineItemDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None
    ):
        self.name = name
        self.description = description
        self.line_items = line_items
        self.text_line_items = text_line_items
        self.custom = custom
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.store = store

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyShoppingListDraft":
        from ._schemas.me import MyShoppingListDraftSchema

        return MyShoppingListDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListDraftSchema

        return MyShoppingListDraftSchema().dump(self)


class MyShoppingListUpdate(_BaseType):
    version: int
    actions: typing.List["MyShoppingListUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["MyShoppingListUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyShoppingListUpdate":
        from ._schemas.me import MyShoppingListUpdateSchema

        return MyShoppingListUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListUpdateSchema

        return MyShoppingListUpdateSchema().dump(self)


class MyShoppingListUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListUpdateAction":
        if data["action"] == "addLineItem":
            from ._schemas.me import MyShoppingListAddLineItemActionSchema

            return MyShoppingListAddLineItemActionSchema().load(data)
        if data["action"] == "addTextLineItem":
            from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

            return MyShoppingListAddTextLineItemActionSchema().load(data)
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

            return MyShoppingListChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeLineItemsOrder":
            from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

            return MyShoppingListChangeLineItemsOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.me import MyShoppingListChangeNameActionSchema

            return MyShoppingListChangeNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemName":
            from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

            return MyShoppingListChangeTextLineItemNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemQuantity":
            from ._schemas.me import (
                MyShoppingListChangeTextLineItemQuantityActionSchema,
            )

            return MyShoppingListChangeTextLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTextLineItemsOrder":
            from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

            return MyShoppingListChangeTextLineItemsOrderActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

            return MyShoppingListRemoveLineItemActionSchema().load(data)
        if data["action"] == "removeTextLineItem":
            from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

            return MyShoppingListRemoveTextLineItemActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

            return MyShoppingListSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

            return MyShoppingListSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.me import (
                MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
            )

            return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(
                data
            )
        if data["action"] == "setDescription":
            from ._schemas.me import MyShoppingListSetDescriptionActionSchema

            return MyShoppingListSetDescriptionActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

            return MyShoppingListSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

            return MyShoppingListSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomField":
            from ._schemas.me import (
                MyShoppingListSetTextLineItemCustomFieldActionSchema,
            )

            return MyShoppingListSetTextLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomType":
            from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

            return MyShoppingListSetTextLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setTextLineItemDescription":
            from ._schemas.me import (
                MyShoppingListSetTextLineItemDescriptionActionSchema,
            )

            return MyShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListUpdateActionSchema

        return MyShoppingListUpdateActionSchema().dump(self)


class MyTransactionDraft(_BaseType):
    #: The time at which the transaction took place.
    timestamp: typing.Optional[datetime.datetime]
    #: The type of this transaction.
    #: Only the `Authorization` or `Charge`
    #: TransactionTypes are allowed here.
    type: "TransactionType"
    amount: "Money"
    #: The identifier that is used by the interface that managed the transaction (usually the PSP).
    #: If a matching interaction was logged in the interfaceInteractions array,
    #: the corresponding interaction should be findable with this ID.
    #: The `state` is set to the `Initial` TransactionState.
    interaction_id: typing.Optional[str]
    #: Custom Fields for the Transaction.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        timestamp: typing.Optional[datetime.datetime] = None,
        type: "TransactionType",
        amount: "Money",
        interaction_id: typing.Optional[str] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.timestamp = timestamp
        self.type = type
        self.amount = amount
        self.interaction_id = interaction_id
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyTransactionDraft":
        from ._schemas.me import MyTransactionDraftSchema

        return MyTransactionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyTransactionDraftSchema

        return MyTransactionDraftSchema().dump(self)


class ReplicaMyCartDraft(_BaseType):
    reference: typing.Union["CartReference", "OrderReference"]

    def __init__(self, *, reference: typing.Union["CartReference", "OrderReference"]):
        self.reference = reference

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReplicaMyCartDraft":
        from ._schemas.me import ReplicaMyCartDraftSchema

        return ReplicaMyCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import ReplicaMyCartDraftSchema

        return ReplicaMyCartDraftSchema().dump(self)


class MyBusinessUnitAddAddressAction(MyBusinessUnitUpdateAction):
    """Adding an address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAddressAdded](ctp:api:type:BusinessUnitAddressAddedMessage) Message."""

    #: The address to add to `addresses`.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddAddressAction":
        from ._schemas.me import MyBusinessUnitAddAddressActionSchema

        return MyBusinessUnitAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddAddressActionSchema

        return MyBusinessUnitAddAddressActionSchema().dump(self)


class MyBusinessUnitAddBillingAddressIdAction(MyBusinessUnitUpdateAction):
    """Adding a billing address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressAdded](ctp:api:type:BusinessUnitBillingAddressAddedMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddBillingAddressIdAction":
        from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

        return MyBusinessUnitAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

        return MyBusinessUnitAddBillingAddressIdActionSchema().dump(self)


class MyBusinessUnitAddShippingAddressIdAction(MyBusinessUnitUpdateAction):
    """Adding a shipping address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressAdded](ctp:api:type:BusinessUnitShippingAddressAddedMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddShippingAddressIdAction":
        from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

        return MyBusinessUnitAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

        return MyBusinessUnitAddShippingAddressIdActionSchema().dump(self)


class MyBusinessUnitChangeAddressAction(MyBusinessUnitUpdateAction):
    """Changing the address on a Business Unit generates the [BusinessUnitAddressChanged](ctp:api:type:BusinessUnitAddressChangedMessage) Message."""

    #: ID of the address to change. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to change. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]
    #: New address to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeAddressAction":
        from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

        return MyBusinessUnitChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

        return MyBusinessUnitChangeAddressActionSchema().dump(self)


class MyBusinessUnitChangeAssociateAction(MyBusinessUnitUpdateAction):
    """Updating the [Associate](ctp:api:type:Associate) on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAssociateChanged](ctp:api:type:BusinessUnitAssociateChangedMessage) Message."""

    #: The Associate to add.
    associate: "AssociateDraft"

    def __init__(self, *, associate: "AssociateDraft"):
        self.associate = associate

        super().__init__(action="changeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeAssociateAction":
        from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

        return MyBusinessUnitChangeAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

        return MyBusinessUnitChangeAssociateActionSchema().dump(self)


class MyBusinessUnitChangeNameAction(MyBusinessUnitUpdateAction):
    """Updating the name on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitNameChanged](ctp:api:type:BusinessUnitNameChangedMessage) Message."""

    #: New name to set.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeNameAction":
        from ._schemas.me import MyBusinessUnitChangeNameActionSchema

        return MyBusinessUnitChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeNameActionSchema

        return MyBusinessUnitChangeNameActionSchema().dump(self)


class MyBusinessUnitChangeParentUnitAction(MyBusinessUnitUpdateAction):
    """Changing the parent of a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitParentUnitChanged](ctp:api:type:BusinessUnitParentUnitChangedMessage) Message. The user must be an Associate with the `Admin` role in the new parent unit."""

    #: New parent unit of the [Business Unit](ctp:api:type:BusinessUnit).
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(self, *, parent_unit: "BusinessUnitResourceIdentifier"):
        self.parent_unit = parent_unit

        super().__init__(action="changeParentUnit")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeParentUnitAction":
        from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

        return MyBusinessUnitChangeParentUnitActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

        return MyBusinessUnitChangeParentUnitActionSchema().dump(self)


class MyBusinessUnitRemoveAddressAction(MyBusinessUnitUpdateAction):
    """Removing the address from a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAddressRemoved](ctp:api:type:BusinessUnitAddressRemovedMessage) Message."""

    #: ID of the address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveAddressAction":
        from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

        return MyBusinessUnitRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

        return MyBusinessUnitRemoveAddressActionSchema().dump(self)


class MyBusinessUnitRemoveAssociateAction(MyBusinessUnitUpdateAction):
    """Removing an [Associate](ctp:api:type:Associate) from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAssociateRemoved](ctp:api:type:BusinessUnitAssociateRemovedMessage) Message."""

    #: [Associate](ctp:api:type:Associate) to remove.
    customer: "CustomerResourceIdentifier"

    def __init__(self, *, customer: "CustomerResourceIdentifier"):
        self.customer = customer

        super().__init__(action="removeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveAssociateAction":
        from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

        return MyBusinessUnitRemoveAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

        return MyBusinessUnitRemoveAssociateActionSchema().dump(self)


class MyBusinessUnitRemoveBillingAddressIdAction(MyBusinessUnitUpdateAction):
    """Removing a billing address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressRemoved](ctp:api:type:BusinessUnitBillingAddressRemovedMessage) Message."""

    #: ID of the billing address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the billing address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveBillingAddressIdAction":
        from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

        return MyBusinessUnitRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

        return MyBusinessUnitRemoveBillingAddressIdActionSchema().dump(self)


class MyBusinessUnitRemoveShippingAddressIdAction(MyBusinessUnitUpdateAction):
    """Removing a shipping address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressRemoved](ctp:api:type:BusinessUnitShippingAddressRemovedMessage) Message."""

    #: ID of the shipping address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the shipping address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveShippingAddressIdAction":
        from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

        return MyBusinessUnitRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

        return MyBusinessUnitRemoveShippingAddressIdActionSchema().dump(self)


class MyBusinessUnitSetAddressCustomFieldAction(MyBusinessUnitUpdateAction):
    #: ID of the `address` to be extended.
    address_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_id = address_id
        self.name = name
        self.value = value

        super().__init__(action="setAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetAddressCustomFieldAction":
        from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

        return MyBusinessUnitSetAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

        return MyBusinessUnitSetAddressCustomFieldActionSchema().dump(self)


class MyBusinessUnitSetAddressCustomTypeAction(MyBusinessUnitUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `address`.
    fields: typing.Optional["FieldContainer"]
    #: ID of the `address` to be extended.
    address_id: str

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None,
        address_id: str
    ):
        self.type = type
        self.fields = fields
        self.address_id = address_id

        super().__init__(action="setAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetAddressCustomTypeAction":
        from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

        return MyBusinessUnitSetAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

        return MyBusinessUnitSetAddressCustomTypeActionSchema().dump(self)


class MyBusinessUnitSetContactEmailAction(MyBusinessUnitUpdateAction):
    """Setting the contact email on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitContactEmailSet](ctp:api:type:BusinessUnitContactEmailSetMessage) Message."""

    #: Email to set.
    #: If `contactEmail` is absent or `null`, the existing contact email, if any, will be removed.
    contact_email: typing.Optional[str]

    def __init__(self, *, contact_email: typing.Optional[str] = None):
        self.contact_email = contact_email

        super().__init__(action="setContactEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetContactEmailAction":
        from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

        return MyBusinessUnitSetContactEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

        return MyBusinessUnitSetContactEmailActionSchema().dump(self)


class MyBusinessUnitSetCustomFieldAction(MyBusinessUnitUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetCustomFieldAction":
        from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

        return MyBusinessUnitSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

        return MyBusinessUnitSetCustomFieldActionSchema().dump(self)


class MyBusinessUnitSetCustomTypeAction(MyBusinessUnitUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the BusinessUnit with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the BusinessUnit.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) for the BusinessUnit.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetCustomTypeAction":
        from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

        return MyBusinessUnitSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

        return MyBusinessUnitSetCustomTypeActionSchema().dump(self)


class MyBusinessUnitSetDefaultBillingAddressAction(MyBusinessUnitUpdateAction):
    """Setting the default billing address on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitDefaultBillingAddressSet](ctp:api:type:BusinessUnitDefaultBillingAddressSetMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetDefaultBillingAddressAction":
        from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

        return MyBusinessUnitSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

        return MyBusinessUnitSetDefaultBillingAddressActionSchema().dump(self)


class MyBusinessUnitSetDefaultShippingAddressAction(MyBusinessUnitUpdateAction):
    """Setting the default shipping address on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitDefaultShippingAddressSet](ctp:api:type:BusinessUnitDefaultShippingAddressSetMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetDefaultShippingAddressAction":
        from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

        return MyBusinessUnitSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

        return MyBusinessUnitSetDefaultShippingAddressActionSchema().dump(self)


class MyCartAddDiscountCodeAction(MyCartUpdateAction):
    code: str

    def __init__(self, *, code: str):
        self.code = code

        super().__init__(action="addDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddDiscountCodeAction":
        from ._schemas.me import MyCartAddDiscountCodeActionSchema

        return MyCartAddDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddDiscountCodeActionSchema

        return MyCartAddDiscountCodeActionSchema().dump(self)


class MyCartAddItemShippingAddressAction(MyCartUpdateAction):
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddItemShippingAddressAction":
        from ._schemas.me import MyCartAddItemShippingAddressActionSchema

        return MyCartAddItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddItemShippingAddressActionSchema

        return MyCartAddItemShippingAddressActionSchema().dump(self)


class MyCartAddLineItemAction(MyCartUpdateAction):
    #: The representation used when creating or updating a [customizable data type](/../api/projects/types#list-of-customizable-data-types) with Custom Fields.
    custom: typing.Optional["CustomFieldsDraft"]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Channel](ctp:api:type:Channel).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    product_id: typing.Optional[str]
    variant_id: typing.Optional[int]
    sku: typing.Optional[str]
    quantity: typing.Optional[int]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Channel](ctp:api:type:Channel).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Draft type that stores amounts in cent precision for the specified currency.
    #:
    #: For storing money values in fractions of the minor unit in a currency, use [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft) instead.
    external_price: typing.Optional["Money"]
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    added_at: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        added_at: typing.Optional[datetime.datetime] = None
    ):
        self.custom = custom
        self.distribution_channel = distribution_channel
        self.external_tax_rate = external_tax_rate
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.supply_channel = supply_channel
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.shipping_details = shipping_details
        self.added_at = added_at

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddLineItemAction":
        from ._schemas.me import MyCartAddLineItemActionSchema

        return MyCartAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddLineItemActionSchema

        return MyCartAddLineItemActionSchema().dump(self)


class MyCartAddPaymentAction(MyCartUpdateAction):
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Payment](ctp:api:type:Payment).
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="addPayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddPaymentAction":
        from ._schemas.me import MyCartAddPaymentActionSchema

        return MyCartAddPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddPaymentActionSchema

        return MyCartAddPaymentActionSchema().dump(self)


class MyCartApplyDeltaToLineItemShippingDetailsTargetsAction(MyCartUpdateAction):
    line_item_id: str
    targets_delta: typing.List["ItemShippingTarget"]

    def __init__(
        self, *, line_item_id: str, targets_delta: typing.List["ItemShippingTarget"]
    ):
        self.line_item_id = line_item_id
        self.targets_delta = targets_delta

        super().__init__(action="applyDeltaToLineItemShippingDetailsTargets")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartApplyDeltaToLineItemShippingDetailsTargetsAction":
        from ._schemas.me import (
            MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import (
            MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().dump(self)


class MyCartChangeLineItemQuantityAction(MyCartUpdateAction):
    line_item_id: str
    quantity: int
    #: Draft type that stores amounts in cent precision for the specified currency.
    #:
    #: For storing money values in fractions of the minor unit in a currency, use [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft) instead.
    external_price: typing.Optional["Money"]
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: str,
        quantity: int,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartChangeLineItemQuantityAction":
        from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

        return MyCartChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

        return MyCartChangeLineItemQuantityActionSchema().dump(self)


class MyCartChangeTaxModeAction(MyCartUpdateAction):
    tax_mode: "TaxMode"

    def __init__(self, *, tax_mode: "TaxMode"):
        self.tax_mode = tax_mode

        super().__init__(action="changeTaxMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartChangeTaxModeAction":
        from ._schemas.me import MyCartChangeTaxModeActionSchema

        return MyCartChangeTaxModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartChangeTaxModeActionSchema

        return MyCartChangeTaxModeActionSchema().dump(self)


class MyCartRecalculateAction(MyCartUpdateAction):
    update_product_data: typing.Optional[bool]

    def __init__(self, *, update_product_data: typing.Optional[bool] = None):
        self.update_product_data = update_product_data

        super().__init__(action="recalculate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRecalculateAction":
        from ._schemas.me import MyCartRecalculateActionSchema

        return MyCartRecalculateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRecalculateActionSchema

        return MyCartRecalculateActionSchema().dump(self)


class MyCartRemoveDiscountCodeAction(MyCartUpdateAction):
    #: [Reference](ctp:api:type:Reference) to a [DiscountCode](ctp:api:type:DiscountCode).
    discount_code: "DiscountCodeReference"

    def __init__(self, *, discount_code: "DiscountCodeReference"):
        self.discount_code = discount_code

        super().__init__(action="removeDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveDiscountCodeAction":
        from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

        return MyCartRemoveDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

        return MyCartRemoveDiscountCodeActionSchema().dump(self)


class MyCartRemoveItemShippingAddressAction(MyCartUpdateAction):
    address_key: str

    def __init__(self, *, address_key: str):
        self.address_key = address_key

        super().__init__(action="removeItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveItemShippingAddressAction":
        from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

        return MyCartRemoveItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

        return MyCartRemoveItemShippingAddressActionSchema().dump(self)


class MyCartRemoveLineItemAction(MyCartUpdateAction):
    line_item_id: str
    quantity: typing.Optional[int]
    #: Draft type that stores amounts in cent precision for the specified currency.
    #:
    #: For storing money values in fractions of the minor unit in a currency, use [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft) instead.
    external_price: typing.Optional["Money"]
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: str,
        quantity: typing.Optional[int] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.shipping_details_to_remove = shipping_details_to_remove

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveLineItemAction":
        from ._schemas.me import MyCartRemoveLineItemActionSchema

        return MyCartRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveLineItemActionSchema

        return MyCartRemoveLineItemActionSchema().dump(self)


class MyCartRemovePaymentAction(MyCartUpdateAction):
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Payment](ctp:api:type:Payment).
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="removePayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemovePaymentAction":
        from ._schemas.me import MyCartRemovePaymentActionSchema

        return MyCartRemovePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemovePaymentActionSchema

        return MyCartRemovePaymentActionSchema().dump(self)


class MyCartSetBillingAddressAction(MyCartUpdateAction):
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetBillingAddressAction":
        from ._schemas.me import MyCartSetBillingAddressActionSchema

        return MyCartSetBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetBillingAddressActionSchema

        return MyCartSetBillingAddressActionSchema().dump(self)


class MyCartSetCountryAction(MyCartUpdateAction):
    #: Two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    country: typing.Optional[str]

    def __init__(self, *, country: typing.Optional[str] = None):
        self.country = country

        super().__init__(action="setCountry")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCountryAction":
        from ._schemas.me import MyCartSetCountryActionSchema

        return MyCartSetCountryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCountryActionSchema

        return MyCartSetCountryActionSchema().dump(self)


class MyCartSetCustomFieldAction(MyCartUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomFieldAction":
        from ._schemas.me import MyCartSetCustomFieldActionSchema

        return MyCartSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomFieldActionSchema

        return MyCartSetCustomFieldActionSchema().dump(self)


class MyCartSetCustomTypeAction(MyCartUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the MyCart with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the MyCart.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the MyCart.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomTypeAction":
        from ._schemas.me import MyCartSetCustomTypeActionSchema

        return MyCartSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomTypeActionSchema

        return MyCartSetCustomTypeActionSchema().dump(self)


class MyCartSetCustomerEmailAction(MyCartUpdateAction):
    email: typing.Optional[str]

    def __init__(self, *, email: typing.Optional[str] = None):
        self.email = email

        super().__init__(action="setCustomerEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomerEmailAction":
        from ._schemas.me import MyCartSetCustomerEmailActionSchema

        return MyCartSetCustomerEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomerEmailActionSchema

        return MyCartSetCustomerEmailActionSchema().dump(self)


class MyCartSetDeleteDaysAfterLastModificationAction(MyCartUpdateAction):
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetDeleteDaysAfterLastModificationAction":
        from ._schemas.me import MyCartSetDeleteDaysAfterLastModificationActionSchema

        return MyCartSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetDeleteDaysAfterLastModificationActionSchema

        return MyCartSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class MyCartSetLineItemCustomFieldAction(MyCartUpdateAction):
    line_item_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, line_item_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemCustomFieldAction":
        from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

        return MyCartSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

        return MyCartSetLineItemCustomFieldActionSchema().dump(self)


class MyCartSetLineItemCustomTypeAction(MyCartUpdateAction):
    line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the LineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the LineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the LineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemCustomTypeAction":
        from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

        return MyCartSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

        return MyCartSetLineItemCustomTypeActionSchema().dump(self)


class MyCartSetLineItemDistributionChannelAction(MyCartUpdateAction):
    line_item_id: str
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Channel](ctp:api:type:Channel).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: str,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.distribution_channel = distribution_channel

        super().__init__(action="setLineItemDistributionChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemDistributionChannelAction":
        from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

        return MyCartSetLineItemDistributionChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

        return MyCartSetLineItemDistributionChannelActionSchema().dump(self)


class MyCartSetLineItemShippingDetailsAction(MyCartUpdateAction):
    line_item_id: str
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: str,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.shipping_details = shipping_details

        super().__init__(action="setLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemShippingDetailsAction":
        from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

        return MyCartSetLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

        return MyCartSetLineItemShippingDetailsActionSchema().dump(self)


class MyCartSetLineItemSupplyChannelAction(MyCartUpdateAction):
    line_item_id: str
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Channel](ctp:api:type:Channel).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: str,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.supply_channel = supply_channel

        super().__init__(action="setLineItemSupplyChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemSupplyChannelAction":
        from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

        return MyCartSetLineItemSupplyChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

        return MyCartSetLineItemSupplyChannelActionSchema().dump(self)


class MyCartSetLocaleAction(MyCartUpdateAction):
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartSetLocaleAction":
        from ._schemas.me import MyCartSetLocaleActionSchema

        return MyCartSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLocaleActionSchema

        return MyCartSetLocaleActionSchema().dump(self)


class MyCartSetShippingAddressAction(MyCartUpdateAction):
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetShippingAddressAction":
        from ._schemas.me import MyCartSetShippingAddressActionSchema

        return MyCartSetShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetShippingAddressActionSchema

        return MyCartSetShippingAddressActionSchema().dump(self)


class MyCartSetShippingMethodAction(MyCartUpdateAction):
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ShippingMethod](ctp:api:type:ShippingMethod).
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method = shipping_method
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetShippingMethodAction":
        from ._schemas.me import MyCartSetShippingMethodActionSchema

        return MyCartSetShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetShippingMethodActionSchema

        return MyCartSetShippingMethodActionSchema().dump(self)


class MyCartUpdateItemShippingAddressAction(MyCartUpdateAction):
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="updateItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartUpdateItemShippingAddressAction":
        from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

        return MyCartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

        return MyCartUpdateItemShippingAddressActionSchema().dump(self)


class MyCustomerAddAddressAction(MyCustomerUpdateAction):
    """Adding an address to the Customer produces the [CustomerAddressAdded](ctp:api:type:CustomerAddressAddedMessage) Message."""

    #: Value to append to the `addresses` array.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddAddressAction":
        from ._schemas.me import MyCustomerAddAddressActionSchema

        return MyCustomerAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddAddressActionSchema

        return MyCustomerAddAddressActionSchema().dump(self)


class MyCustomerAddBillingAddressIdAction(MyCustomerUpdateAction):
    """Adds an address from the `addresses` array to `billingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddBillingAddressIdAction":
        from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

        return MyCustomerAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

        return MyCustomerAddBillingAddressIdActionSchema().dump(self)


class MyCustomerAddShippingAddressIdAction(MyCustomerUpdateAction):
    """Adds an address from the `addresses` array to `shippingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddShippingAddressIdAction":
        from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

        return MyCustomerAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

        return MyCustomerAddShippingAddressIdActionSchema().dump(self)


class MyCustomerChangeAddressAction(MyCustomerUpdateAction):
    """Changing an address of the Customer produces the [CustomerAddressChanged](ctp:api:type:CustomerAddressChangedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to change.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to change.
    address_key: typing.Optional[str]
    #: Value to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerChangeAddressAction":
        from ._schemas.me import MyCustomerChangeAddressActionSchema

        return MyCustomerChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerChangeAddressActionSchema

        return MyCustomerChangeAddressActionSchema().dump(self)


class MyCustomerChangeEmailAction(MyCustomerUpdateAction):
    """Changing the email of the Customer produces the [CustomerEmailChanged](ctp:api:type:CustomerEmailChangedMessage) Message."""

    #: New value to set.
    email: str

    def __init__(self, *, email: str):
        self.email = email

        super().__init__(action="changeEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerChangeEmailAction":
        from ._schemas.me import MyCustomerChangeEmailActionSchema

        return MyCustomerChangeEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerChangeEmailActionSchema

        return MyCustomerChangeEmailActionSchema().dump(self)


class MyCustomerRemoveAddressAction(MyCustomerUpdateAction):
    """Removing an address of the Customer produces the [CustomerAddressRemoved](ctp:api:type:CustomerAddressRemovedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveAddressAction":
        from ._schemas.me import MyCustomerRemoveAddressActionSchema

        return MyCustomerRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveAddressActionSchema

        return MyCustomerRemoveAddressActionSchema().dump(self)


class MyCustomerRemoveBillingAddressIdAction(MyCustomerUpdateAction):
    """Removes an existing billing address from `billingAddressesIds`.
    If the billing address is the default billing address, the `defaultBillingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveBillingAddressIdAction":
        from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

        return MyCustomerRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

        return MyCustomerRemoveBillingAddressIdActionSchema().dump(self)


class MyCustomerRemoveShippingAddressIdAction(MyCustomerUpdateAction):
    """Removes an existing shipping address from `shippingAddressesIds`.
    If the shipping address is the default shipping address, the `defaultShippingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveShippingAddressIdAction":
        from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

        return MyCustomerRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

        return MyCustomerRemoveShippingAddressIdActionSchema().dump(self)


class MyCustomerSetCompanyNameAction(MyCustomerUpdateAction):
    """Setting the `companyName` field on the Customer produces the [CustomerCompanyNameSet](ctp:api:type:CustomerCompanyNameSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    company_name: typing.Optional[str]

    def __init__(self, *, company_name: typing.Optional[str] = None):
        self.company_name = company_name

        super().__init__(action="setCompanyName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCompanyNameAction":
        from ._schemas.me import MyCustomerSetCompanyNameActionSchema

        return MyCustomerSetCompanyNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCompanyNameActionSchema

        return MyCustomerSetCompanyNameActionSchema().dump(self)


class MyCustomerSetCustomFieldAction(MyCustomerUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCustomFieldAction":
        from ._schemas.me import MyCustomerSetCustomFieldActionSchema

        return MyCustomerSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCustomFieldActionSchema

        return MyCustomerSetCustomFieldActionSchema().dump(self)


class MyCustomerSetCustomTypeAction(MyCustomerUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the MyCustomer with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the MyCustomer.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the MyCustomer.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCustomTypeAction":
        from ._schemas.me import MyCustomerSetCustomTypeActionSchema

        return MyCustomerSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCustomTypeActionSchema

        return MyCustomerSetCustomTypeActionSchema().dump(self)


class MyCustomerSetDateOfBirthAction(MyCustomerUpdateAction):
    """Setting the date of birth of the Customer produces the [CustomerDateOfBirthSet](ctp:api:type:CustomerDateOfBirthSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    date_of_birth: typing.Optional[datetime.date]

    def __init__(self, *, date_of_birth: typing.Optional[datetime.date] = None):
        self.date_of_birth = date_of_birth

        super().__init__(action="setDateOfBirth")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDateOfBirthAction":
        from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

        return MyCustomerSetDateOfBirthActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

        return MyCustomerSetDateOfBirthActionSchema().dump(self)


class MyCustomerSetDefaultBillingAddressAction(MyCustomerUpdateAction):
    """Sets the default billing address from `addresses`.
    If the address is not currently a billing address, it is added to `billingAddressIds`. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDefaultBillingAddressAction":
        from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

        return MyCustomerSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

        return MyCustomerSetDefaultBillingAddressActionSchema().dump(self)


class MyCustomerSetDefaultShippingAddressAction(MyCustomerUpdateAction):
    """Sets the default shipping address from `addresses`.
    If the address is not currently a shipping address, it is added to `shippingAddressIds`. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDefaultShippingAddressAction":
        from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

        return MyCustomerSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

        return MyCustomerSetDefaultShippingAddressActionSchema().dump(self)


class MyCustomerSetFirstNameAction(MyCustomerUpdateAction):
    """Setting the first name of the Customer produces the [CustomerFirstNameSetMessage](ctp:api:type:CustomerFirstNameSetMessage)."""

    #: Value to set.
    #: If empty, any existing value is removed.
    first_name: typing.Optional[str]

    def __init__(self, *, first_name: typing.Optional[str] = None):
        self.first_name = first_name

        super().__init__(action="setFirstName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetFirstNameAction":
        from ._schemas.me import MyCustomerSetFirstNameActionSchema

        return MyCustomerSetFirstNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetFirstNameActionSchema

        return MyCustomerSetFirstNameActionSchema().dump(self)


class MyCustomerSetLastNameAction(MyCustomerUpdateAction):
    """Setting the last name of the Customer produces the [CustomerLastNameSetMessage](ctp:api:type:CustomerLastNameSetMessage)."""

    #: Value to set.
    #: If empty, any existing value is removed.
    last_name: typing.Optional[str]

    def __init__(self, *, last_name: typing.Optional[str] = None):
        self.last_name = last_name

        super().__init__(action="setLastName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetLastNameAction":
        from ._schemas.me import MyCustomerSetLastNameActionSchema

        return MyCustomerSetLastNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetLastNameActionSchema

        return MyCustomerSetLastNameActionSchema().dump(self)


class MyCustomerSetLocaleAction(MyCustomerUpdateAction):
    #: Value to set.
    #: Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetLocaleAction":
        from ._schemas.me import MyCustomerSetLocaleActionSchema

        return MyCustomerSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetLocaleActionSchema

        return MyCustomerSetLocaleActionSchema().dump(self)


class MyCustomerSetMiddleNameAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    middle_name: typing.Optional[str]

    def __init__(self, *, middle_name: typing.Optional[str] = None):
        self.middle_name = middle_name

        super().__init__(action="setMiddleName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetMiddleNameAction":
        from ._schemas.me import MyCustomerSetMiddleNameActionSchema

        return MyCustomerSetMiddleNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetMiddleNameActionSchema

        return MyCustomerSetMiddleNameActionSchema().dump(self)


class MyCustomerSetSalutationAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    salutation: typing.Optional[str]

    def __init__(self, *, salutation: typing.Optional[str] = None):
        self.salutation = salutation

        super().__init__(action="setSalutation")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetSalutationAction":
        from ._schemas.me import MyCustomerSetSalutationActionSchema

        return MyCustomerSetSalutationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetSalutationActionSchema

        return MyCustomerSetSalutationActionSchema().dump(self)


class MyCustomerSetTitleAction(MyCustomerUpdateAction):
    """Setting the title of the Customer produces the [CustomerTitleSetMessage](ctp:api:type:CustomerTitleSetMessage)."""

    #: Value to set.
    #: If empty, any existing value is removed.
    title: typing.Optional[str]

    def __init__(self, *, title: typing.Optional[str] = None):
        self.title = title

        super().__init__(action="setTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetTitleAction":
        from ._schemas.me import MyCustomerSetTitleActionSchema

        return MyCustomerSetTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetTitleActionSchema

        return MyCustomerSetTitleActionSchema().dump(self)


class MyCustomerSetVatIdAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    vat_id: typing.Optional[str]

    def __init__(self, *, vat_id: typing.Optional[str] = None):
        self.vat_id = vat_id

        super().__init__(action="setVatId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetVatIdAction":
        from ._schemas.me import MyCustomerSetVatIdActionSchema

        return MyCustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetVatIdActionSchema

        return MyCustomerSetVatIdActionSchema().dump(self)


class MyPaymentAddTransactionAction(MyPaymentUpdateAction):
    transaction: "TransactionDraft"

    def __init__(self, *, transaction: "TransactionDraft"):
        self.transaction = transaction

        super().__init__(action="addTransaction")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentAddTransactionAction":
        from ._schemas.me import MyPaymentAddTransactionActionSchema

        return MyPaymentAddTransactionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentAddTransactionActionSchema

        return MyPaymentAddTransactionActionSchema().dump(self)


class MyPaymentChangeAmountPlannedAction(MyPaymentUpdateAction):
    #: Draft type that stores amounts in cent precision for the specified currency.
    #:
    #: For storing money values in fractions of the minor unit in a currency, use [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft) instead.
    amount: "Money"

    def __init__(self, *, amount: "Money"):
        self.amount = amount

        super().__init__(action="changeAmountPlanned")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentChangeAmountPlannedAction":
        from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

        return MyPaymentChangeAmountPlannedActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

        return MyPaymentChangeAmountPlannedActionSchema().dump(self)


class MyPaymentSetCustomFieldAction(MyPaymentUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetCustomFieldAction":
        from ._schemas.me import MyPaymentSetCustomFieldActionSchema

        return MyPaymentSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetCustomFieldActionSchema

        return MyPaymentSetCustomFieldActionSchema().dump(self)


class MyPaymentSetMethodInfoInterfaceAction(MyPaymentUpdateAction):
    interface: str

    def __init__(self, *, interface: str):
        self.interface = interface

        super().__init__(action="setMethodInfoInterface")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoInterfaceAction":
        from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

        return MyPaymentSetMethodInfoInterfaceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

        return MyPaymentSetMethodInfoInterfaceActionSchema().dump(self)


class MyPaymentSetMethodInfoMethodAction(MyPaymentUpdateAction):
    method: typing.Optional[str]

    def __init__(self, *, method: typing.Optional[str] = None):
        self.method = method

        super().__init__(action="setMethodInfoMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoMethodAction":
        from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

        return MyPaymentSetMethodInfoMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

        return MyPaymentSetMethodInfoMethodActionSchema().dump(self)


class MyPaymentSetMethodInfoNameAction(MyPaymentUpdateAction):
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    name: typing.Optional["LocalizedString"]

    def __init__(self, *, name: typing.Optional["LocalizedString"] = None):
        self.name = name

        super().__init__(action="setMethodInfoName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoNameAction":
        from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

        return MyPaymentSetMethodInfoNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

        return MyPaymentSetMethodInfoNameActionSchema().dump(self)


class MyPaymentSetTransactionCustomFieldAction(MyPaymentUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setTransactionCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetTransactionCustomFieldAction":
        from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

        return MyPaymentSetTransactionCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

        return MyPaymentSetTransactionCustomFieldActionSchema().dump(self)


class MyQuoteChangeMyQuoteStateAction(MyQuoteUpdateAction):
    #: New state to be set for the Quote.
    quote_state: "MyQuoteState"

    def __init__(self, *, quote_state: "MyQuoteState"):
        self.quote_state = quote_state

        super().__init__(action="changeMyQuoteState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteChangeMyQuoteStateAction":
        from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

        return MyQuoteChangeMyQuoteStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

        return MyQuoteChangeMyQuoteStateActionSchema().dump(self)


class MyQuoteRequestCancelAction(MyQuoteRequestUpdateAction):
    """Transitions the `quoteRequestState` of the Quote Request to `Cancelled`. Can only be used when the Quote Request is in state `Submitted`."""

    def __init__(self):

        super().__init__(action="cancelQuoteRequest")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteRequestCancelAction":
        from ._schemas.me import MyQuoteRequestCancelActionSchema

        return MyQuoteRequestCancelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestCancelActionSchema

        return MyQuoteRequestCancelActionSchema().dump(self)


class MyShoppingListAddLineItemAction(MyShoppingListUpdateAction):
    sku: typing.Optional[str]
    product_id: typing.Optional[str]
    variant_id: typing.Optional[int]
    quantity: typing.Optional[int]
    added_at: typing.Optional[datetime.datetime]
    #: The representation used when creating or updating a [customizable data type](/../api/projects/types#list-of-customizable-data-types) with Custom Fields.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        sku: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.sku = sku
        self.product_id = product_id
        self.variant_id = variant_id
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListAddLineItemAction":
        from ._schemas.me import MyShoppingListAddLineItemActionSchema

        return MyShoppingListAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListAddLineItemActionSchema

        return MyShoppingListAddLineItemActionSchema().dump(self)


class MyShoppingListAddTextLineItemAction(MyShoppingListUpdateAction):
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    name: "LocalizedString"
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    description: typing.Optional["LocalizedString"]
    quantity: typing.Optional[int]
    added_at: typing.Optional[datetime.datetime]
    #: The representation used when creating or updating a [customizable data type](/../api/projects/types#list-of-customizable-data-types) with Custom Fields.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.description = description
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListAddTextLineItemAction":
        from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

        return MyShoppingListAddTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

        return MyShoppingListAddTextLineItemActionSchema().dump(self)


class MyShoppingListChangeLineItemQuantityAction(MyShoppingListUpdateAction):
    line_item_id: str
    quantity: int

    def __init__(self, *, line_item_id: str, quantity: int):
        self.line_item_id = line_item_id
        self.quantity = quantity

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeLineItemQuantityAction":
        from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

        return MyShoppingListChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

        return MyShoppingListChangeLineItemQuantityActionSchema().dump(self)


class MyShoppingListChangeLineItemsOrderAction(MyShoppingListUpdateAction):
    line_item_order: typing.List["str"]

    def __init__(self, *, line_item_order: typing.List["str"]):
        self.line_item_order = line_item_order

        super().__init__(action="changeLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeLineItemsOrderAction":
        from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

        return MyShoppingListChangeLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

        return MyShoppingListChangeLineItemsOrderActionSchema().dump(self)


class MyShoppingListChangeNameAction(MyShoppingListUpdateAction):
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeNameAction":
        from ._schemas.me import MyShoppingListChangeNameActionSchema

        return MyShoppingListChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeNameActionSchema

        return MyShoppingListChangeNameActionSchema().dump(self)


class MyShoppingListChangeTextLineItemNameAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    name: "LocalizedString"

    def __init__(self, *, text_line_item_id: str, name: "LocalizedString"):
        self.text_line_item_id = text_line_item_id
        self.name = name

        super().__init__(action="changeTextLineItemName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemNameAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

        return MyShoppingListChangeTextLineItemNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

        return MyShoppingListChangeTextLineItemNameActionSchema().dump(self)


class MyShoppingListChangeTextLineItemQuantityAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    quantity: int

    def __init__(self, *, text_line_item_id: str, quantity: int):
        self.text_line_item_id = text_line_item_id
        self.quantity = quantity

        super().__init__(action="changeTextLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemQuantityAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemQuantityActionSchema

        return MyShoppingListChangeTextLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemQuantityActionSchema

        return MyShoppingListChangeTextLineItemQuantityActionSchema().dump(self)


class MyShoppingListChangeTextLineItemsOrderAction(MyShoppingListUpdateAction):
    text_line_item_order: typing.List["str"]

    def __init__(self, *, text_line_item_order: typing.List["str"]):
        self.text_line_item_order = text_line_item_order

        super().__init__(action="changeTextLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemsOrderAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

        return MyShoppingListChangeTextLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

        return MyShoppingListChangeTextLineItemsOrderActionSchema().dump(self)


class MyShoppingListRemoveLineItemAction(MyShoppingListUpdateAction):
    line_item_id: str
    quantity: typing.Optional[int]

    def __init__(self, *, line_item_id: str, quantity: typing.Optional[int] = None):
        self.line_item_id = line_item_id
        self.quantity = quantity

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListRemoveLineItemAction":
        from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

        return MyShoppingListRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

        return MyShoppingListRemoveLineItemActionSchema().dump(self)


class MyShoppingListRemoveTextLineItemAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    quantity: typing.Optional[int]

    def __init__(
        self, *, text_line_item_id: str, quantity: typing.Optional[int] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.quantity = quantity

        super().__init__(action="removeTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListRemoveTextLineItemAction":
        from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

        return MyShoppingListRemoveTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

        return MyShoppingListRemoveTextLineItemActionSchema().dump(self)


class MyShoppingListSetCustomFieldAction(MyShoppingListUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetCustomFieldAction":
        from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

        return MyShoppingListSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

        return MyShoppingListSetCustomFieldActionSchema().dump(self)


class MyShoppingListSetCustomTypeAction(MyShoppingListUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the MyShoppingList with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the MyShoppingList.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the MyShoppingList.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetCustomTypeAction":
        from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

        return MyShoppingListSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

        return MyShoppingListSetCustomTypeActionSchema().dump(self)


class MyShoppingListSetDeleteDaysAfterLastModificationAction(
    MyShoppingListUpdateAction
):
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetDeleteDaysAfterLastModificationAction":
        from ._schemas.me import (
            MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import (
            MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class MyShoppingListSetDescriptionAction(MyShoppingListUpdateAction):
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetDescriptionAction":
        from ._schemas.me import MyShoppingListSetDescriptionActionSchema

        return MyShoppingListSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetDescriptionActionSchema

        return MyShoppingListSetDescriptionActionSchema().dump(self)


class MyShoppingListSetLineItemCustomFieldAction(MyShoppingListUpdateAction):
    line_item_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, line_item_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetLineItemCustomFieldAction":
        from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

        return MyShoppingListSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

        return MyShoppingListSetLineItemCustomFieldActionSchema().dump(self)


class MyShoppingListSetLineItemCustomTypeAction(MyShoppingListUpdateAction):
    line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the LineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the LineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the LineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetLineItemCustomTypeAction":
        from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

        return MyShoppingListSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

        return MyShoppingListSetLineItemCustomTypeActionSchema().dump(self)


class MyShoppingListSetTextLineItemCustomFieldAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](/../api/errors#general-400-invalid-operation) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        text_line_item_id: str,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.name = name
        self.value = value

        super().__init__(action="setTextLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemCustomFieldAction":
        from ._schemas.me import MyShoppingListSetTextLineItemCustomFieldActionSchema

        return MyShoppingListSetTextLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemCustomFieldActionSchema

        return MyShoppingListSetTextLineItemCustomFieldActionSchema().dump(self)


class MyShoppingListSetTextLineItemCustomTypeAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the TextLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the TextLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the TextLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        text_line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setTextLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemCustomTypeAction":
        from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

        return MyShoppingListSetTextLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

        return MyShoppingListSetTextLineItemCustomTypeActionSchema().dump(self)


class MyShoppingListSetTextLineItemDescriptionAction(MyShoppingListUpdateAction):
    text_line_item_id: str
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        text_line_item_id: str,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.description = description

        super().__init__(action="setTextLineItemDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemDescriptionAction":
        from ._schemas.me import MyShoppingListSetTextLineItemDescriptionActionSchema

        return MyShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemDescriptionActionSchema

        return MyShoppingListSetTextLineItemDescriptionActionSchema().dump(self)
