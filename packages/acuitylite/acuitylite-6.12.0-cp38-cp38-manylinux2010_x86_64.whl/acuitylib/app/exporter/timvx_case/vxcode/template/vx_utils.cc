/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*   Match timvx #TIMVX_VERSION#
*
*   Neural Network appliction customer source file
****************************************************************************/
#include "vx_utils.h"

#include <cstring>
#include <iostream>
#include <fstream>

using namespace #NAMESPACE#;

namespace utils
{

std::vector<std::vector<char>> load_input_data(char **argv, int input_count, std::vector<uint32_t> input_size_bytes)
{
    std::vector<std::vector<char>> Data;
    for (int i = 0; i < input_count; i++)
    {
        std::ifstream fin(argv[i + 2], std::ios::in | std::ios::binary);
        if (fin)
        {
            std::vector<char> input_data;
            fin.seekg(0, std::ios::end);
            int size = fin.tellg();
            fin.seekg(0, std::ios::beg);
            char *buffer = new char[size];
            std::cout<<"File "<<argv[i + 2] <<" size:"<<size<<std::endl;
            fin.read(buffer, size);
            fin.close();
            input_data.assign(buffer, buffer + input_size_bytes[i]);
            Data.push_back(input_data);
            free(buffer);
        }
        else
        {
            std::cout<<"Load file "<<argv[i + 2]<<" failed"<<std::endl;
        }
    }
    return Data;
}

int postprocess()
{
    /* Print top 5 of neural network output0 (CPP) */
    auto output = #NETWORK_NAME#::outputs_tensor[0];
    std::vector<#NETWORK_NAME#::output_0_type> output_data;
    std::vector<std::tuple<int, #NETWORK_NAME#::output_0_type>> data;
    uint32_t size = 1;
    for(uint32_t i = 0; i < output->GetShape().size(); i++)
    {
        size *= output->GetShape()[i];
    }
    output_data.resize(size);
    if (!output->CopyDataFromTensor(output_data.data()))
    {
        std::cout << "Copy output data fail." << std::endl;
        return -1;
    }
    auto prob = output_data.data();
    int outputCount = output_data.size();
    int topNum = 5;
    for (int i = 0; i < outputCount; i++)
    {
        data.push_back(std::make_tuple(i, prob[i]));
    }
    std::sort(data.begin(), data.end(),
              [](auto& a, auto& b) { return std::get<1>(a) > std::get<1>(b); });
    std::cout << " --- Top" << topNum << " ---" << std::endl;
    for (int i = 0; i < topNum; i++)
    {
        std::cout << std::setw(3) << std::get<0>(data[i]) << ": "
                << std::setprecision(6) << (float)std::get<1>(data[i]) << std::endl;
    }
    return 0;
}

}  // namespace utils

