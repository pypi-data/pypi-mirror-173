'''
## Amplify CLI cdk-exported-backend

[![Integration Tests](https://github.com/aws-amplify/amplify-cli-export-construct/actions/workflows/integration-test.yml/badge.svg?branch=main)](https://github.com/aws-amplify/amplify-cli-export-construct/actions/workflows/integration-test.yml)

This CDK construct is used to include the CloudFormation resources generated by [Amplify CLI Export command](https://docs.amplify.aws/cli/usage/export-to-cdk/). The construct handles assets and CloudFormation files. It offers abstractions over the Amplify CLI generated cloud resources.

The library is published under the following

|Language	|Repository	|
|---	|---	|
|Typescript/Javascript	| [@aws-amplify/cdk-exported-backend](https://www.npmjs.com/package/@aws-amplify/cdk-exported-backend)	|
|Python	| [aws-amplify.cdk.exported-backend](https://pypi.org/project/aws-amplify.cdk.exported-backend/)	|
|Java	| [com.amplifyframework:exported-backend](https://search.maven.org/artifact/com.amplifyframework/exported-backend)	|

### Usage

Install via NPM:

```bash
npm i @aws-amplify/cdk-exported-backend@latest
```

Add to your CDK app:

```js
import { AmplifyExportedBackend }  from '@aws-amplify/cdk-exported-backend';
...
const amplifyExport = new AmplifyExportedBackend(app, 'AmplifyExportedBackend', {
  path: './amplify-export-myAmplifyApp',
  amplifyEnvironment: 'dev',
});


```

#### Construct Props

The construct props extend [stack props](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_core.StackProps.html) and can be used to override the root stack properties.

|Name	|Type	|Description	|Required	|Default	|
|---	|---	|---	|---	|---	|
|path	|String	|You can use the absolute or the relative path to the location of the folder. When using relative paths it's important to note that the path is relative to the root of your CDK application	|Yes	|undefined	|
|stage	|String	|This works similar to Amplify CLI's environment names. The construct makes modification to be able to integrate into the CDK app.	|Yes	| undefined	|

Deploy this to your account

```bash
cdk deploy
```

### Contributing

We welcome community contributions and pull requests.

### Security

See [CONTRIBUTING](CONTRIBUTING.md#security-issue-notifications) for more information.

### License

This project is licensed under the Apache-2.0 License.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import aws_cdk
import aws_cdk.aws_apigateway
import aws_cdk.aws_appsync
import aws_cdk.aws_cognito
import aws_cdk.aws_lambda
import aws_cdk.aws_s3_deployment
import aws_cdk.cloudformation_include
import constructs


class APIGraphQLIncludedNestedStack(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-amplify/cdk-exported-backend.APIGraphQLIncludedNestedStack",
):
    def __init__(
        self,
        *,
        included_template: aws_cdk.cloudformation_include.CfnInclude,
        stack: aws_cdk.NestedStack,
    ) -> None:
        '''
        :param included_template: The CfnInclude that represents the template, which can be used to access Resources and other template elements.
        :param stack: The NestedStack object which represents the scope of the template.
        '''
        included_stack = aws_cdk.cloudformation_include.IncludedNestedStack(
            included_template=included_template, stack=stack
        )

        jsii.create(self.__class__, self, [included_stack])

    @jsii.member(jsii_name="appSyncAPIKey")
    def app_sync_api_key(self) -> aws_cdk.aws_appsync.CfnApiKey:
        '''
        :return: Appsync Api Key {CfnApiKey} of the auth stack

        :throws: {CfnResourceNotFoundError} if not found
        '''
        return typing.cast(aws_cdk.aws_appsync.CfnApiKey, jsii.invoke(self, "appSyncAPIKey", []))

    @jsii.member(jsii_name="getResourceConstruct")
    def get_resource_construct(self, logical_id: builtins.str) -> typing.Any:
        '''
        :param logical_id: -
        '''
        if __debug__:
            def stub(logical_id: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument logical_id", value=logical_id, expected_type=type_hints["logical_id"])
        return typing.cast(typing.Any, jsii.invoke(self, "getResourceConstruct", [logical_id]))

    @jsii.member(jsii_name="graphQLAPI")
    def graph_qlapi(self) -> aws_cdk.aws_appsync.CfnGraphQLApi:
        '''
        :return: of the api stack

        :throws: {CfnResourceNotFoundError} if not found
        '''
        return typing.cast(aws_cdk.aws_appsync.CfnGraphQLApi, jsii.invoke(self, "graphQLAPI", []))

    @jsii.member(jsii_name="graphQLSchema")
    def graph_ql_schema(self) -> aws_cdk.aws_appsync.CfnGraphQLSchema:
        '''
        :return: of the api stack

        :throws: {CfnResourceNotFoundError} if not found
        '''
        return typing.cast(aws_cdk.aws_appsync.CfnGraphQLSchema, jsii.invoke(self, "graphQLSchema", []))

    @jsii.member(jsii_name="modelNestedStack")
    def model_nested_stack(
        self,
        table_name: builtins.str,
    ) -> aws_cdk.cloudformation_include.IncludedNestedStack:
        '''
        :param table_name: is the model name in your Graph QL API.

        :return: return nested stack
        '''
        if __debug__:
            def stub(table_name: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
        return typing.cast(aws_cdk.cloudformation_include.IncludedNestedStack, jsii.invoke(self, "modelNestedStack", [table_name]))

    @builtins.property
    @jsii.member(jsii_name="includedTemplate")
    def included_template(self) -> aws_cdk.cloudformation_include.CfnInclude:
        return typing.cast(aws_cdk.cloudformation_include.CfnInclude, jsii.get(self, "includedTemplate"))

    @included_template.setter
    def included_template(
        self,
        value: aws_cdk.cloudformation_include.CfnInclude,
    ) -> None:
        if __debug__:
            def stub(value: aws_cdk.cloudformation_include.CfnInclude) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "includedTemplate", value)

    @builtins.property
    @jsii.member(jsii_name="stack")
    def stack(self) -> aws_cdk.NestedStack:
        return typing.cast(aws_cdk.NestedStack, jsii.get(self, "stack"))

    @stack.setter
    def stack(self, value: aws_cdk.NestedStack) -> None:
        if __debug__:
            def stub(value: aws_cdk.NestedStack) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stack", value)


class APIRestIncludedStack(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-amplify/cdk-exported-backend.APIRestIncludedStack",
):
    def __init__(
        self,
        included_stack: typing.Union[aws_cdk.cloudformation_include.IncludedNestedStack, typing.Dict[str, typing.Any]],
        resource_name: builtins.str,
    ) -> None:
        '''
        :param included_stack: -
        :param resource_name: -
        '''
        if __debug__:
            def stub(
                included_stack: typing.Union[aws_cdk.cloudformation_include.IncludedNestedStack, typing.Dict[str, typing.Any]],
                resource_name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument included_stack", value=included_stack, expected_type=type_hints["included_stack"])
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
        jsii.create(self.__class__, self, [included_stack, resource_name])

    @jsii.member(jsii_name="apiDeployment")
    def api_deployment(self) -> aws_cdk.aws_apigateway.CfnDeployment:
        '''Gets the Deployment of the Rest API.'''
        return typing.cast(aws_cdk.aws_apigateway.CfnDeployment, jsii.invoke(self, "apiDeployment", []))

    @jsii.member(jsii_name="getResourceConstruct")
    def get_resource_construct(self, logical_id: builtins.str) -> typing.Any:
        '''
        :param logical_id: -
        '''
        if __debug__:
            def stub(logical_id: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument logical_id", value=logical_id, expected_type=type_hints["logical_id"])
        return typing.cast(typing.Any, jsii.invoke(self, "getResourceConstruct", [logical_id]))

    @jsii.member(jsii_name="restAPI")
    def rest_api(self) -> aws_cdk.aws_apigateway.CfnRestApi:
        '''Gets the RestApi of the API stack.'''
        return typing.cast(aws_cdk.aws_apigateway.CfnRestApi, jsii.invoke(self, "restAPI", []))

    @builtins.property
    @jsii.member(jsii_name="includedTemplate")
    def included_template(self) -> aws_cdk.cloudformation_include.CfnInclude:
        return typing.cast(aws_cdk.cloudformation_include.CfnInclude, jsii.get(self, "includedTemplate"))

    @included_template.setter
    def included_template(
        self,
        value: aws_cdk.cloudformation_include.CfnInclude,
    ) -> None:
        if __debug__:
            def stub(value: aws_cdk.cloudformation_include.CfnInclude) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "includedTemplate", value)

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @resource_name.setter
    def resource_name(self, value: builtins.str) -> None:
        if __debug__:
            def stub(value: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceName", value)

    @builtins.property
    @jsii.member(jsii_name="stack")
    def stack(self) -> aws_cdk.NestedStack:
        return typing.cast(aws_cdk.NestedStack, jsii.get(self, "stack"))

    @stack.setter
    def stack(self, value: aws_cdk.NestedStack) -> None:
        if __debug__:
            def stub(value: aws_cdk.NestedStack) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stack", value)


class AmplifyExportedBackend(
    constructs.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-amplify/cdk-exported-backend.AmplifyExportedBackend",
):
    '''- Used to include the backend generated by running ``amplify export --out <path>`` into the cdk app.

    :see:
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        amplify_environment: builtins.str,
        path: builtins.str,
        analytics_reporting: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[aws_cdk.Environment, typing.Dict[str, typing.Any]]] = None,
        stack_name: typing.Optional[builtins.str] = None,
        synthesizer: typing.Optional[aws_cdk.IStackSynthesizer] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        termination_protection: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: The parent construct of this template.
        :param id: The ID of this construct.
        :param amplify_environment: The Amplify CLI environment deploy to The amplify backend requires a stage to deploy. Default: is 'dev'
        :param path: The path to the exported folder that contains the artifacts for the Amplify CLI backend ex: ./amplify-synth-out/.
        :param analytics_reporting: Include runtime versioning information in this Stack. Default: ``analyticsReporting`` setting of containing ``App``, or value of 'aws:cdk:version-reporting' context key
        :param description: A description of the stack. Default: - No description.
        :param env: The AWS environment (account/region) where this stack will be deployed. Set the ``region``/``account`` fields of ``env`` to either a concrete value to select the indicated environment (recommended for production stacks), or to the values of environment variables ``CDK_DEFAULT_REGION``/``CDK_DEFAULT_ACCOUNT`` to let the target environment depend on the AWS credentials/configuration that the CDK CLI is executed under (recommended for development stacks). If the ``Stack`` is instantiated inside a ``Stage``, any undefined ``region``/``account`` fields from ``env`` will default to the same field on the encompassing ``Stage``, if configured there. If either ``region`` or ``account`` are not set nor inherited from ``Stage``, the Stack will be considered "*environment-agnostic*"". Environment-agnostic stacks can be deployed to any environment but may not be able to take advantage of all features of the CDK. For example, they will not be able to use environmental context lookups such as ``ec2.Vpc.fromLookup`` and will not automatically translate Service Principals to the right format based on the environment's AWS partition, and other such enhancements. Default: - The environment of the containing ``Stage`` if available, otherwise create the stack will be environment-agnostic.
        :param stack_name: Name to deploy the stack with. Default: - Derived from construct path.
        :param synthesizer: Synthesis method to use while deploying this stack. Default: - ``DefaultStackSynthesizer`` if the ``@aws-cdk/core:newStyleStackSynthesis`` feature flag is set, ``LegacyStackSynthesizer`` otherwise.
        :param tags: Stack tags that will be applied to all the taggable resources and the stack itself. Default: {}
        :param termination_protection: Whether to enable termination protection for this stack. Default: false
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                amplify_environment: builtins.str,
                path: builtins.str,
                analytics_reporting: typing.Optional[builtins.bool] = None,
                description: typing.Optional[builtins.str] = None,
                env: typing.Optional[typing.Union[aws_cdk.Environment, typing.Dict[str, typing.Any]]] = None,
                stack_name: typing.Optional[builtins.str] = None,
                synthesizer: typing.Optional[aws_cdk.IStackSynthesizer] = None,
                tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                termination_protection: typing.Optional[builtins.bool] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AmplifyExportedBackendProps(
            amplify_environment=amplify_environment,
            path=path,
            analytics_reporting=analytics_reporting,
            description=description,
            env=env,
            stack_name=stack_name,
            synthesizer=synthesizer,
            tags=tags,
            termination_protection=termination_protection,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiRestNestedStack")
    def api_rest_nested_stack(
        self,
        resource_name: builtins.str,
    ) -> APIRestIncludedStack:
        '''Use this to get rest api stack from the backend.

        :param resource_name: -

        :return: the nested of type Rest API

        :throws: {AmplifyCategoryNotFoundError} if the API Rest stack doesn't exist
        '''
        if __debug__:
            def stub(resource_name: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
        return typing.cast(APIRestIncludedStack, jsii.invoke(self, "apiRestNestedStack", [resource_name]))

    @jsii.member(jsii_name="authNestedStack")
    def auth_nested_stack(self) -> "AuthIncludedNestedStack":
        '''Method to get the auth stack.

        :return: the nested stack of type {IAuthIncludeNestedStack}

        :function: true
        :method: true
        :throws: {AmplifyCategoryNotFoundError} if the auth stack doesn't exist
        '''
        return typing.cast("AuthIncludedNestedStack", jsii.invoke(self, "authNestedStack", []))

    @jsii.member(jsii_name="filterCategory")
    def _filter_category(
        self,
        category: builtins.str,
        service: typing.Optional[builtins.str] = None,
        resource_name: typing.Optional[builtins.str] = None,
    ) -> typing.List["CategoryStackMapping"]:
        '''
        :param category: -
        :param service: -
        :param resource_name: -
        '''
        if __debug__:
            def stub(
                category: builtins.str,
                service: typing.Optional[builtins.str] = None,
                resource_name: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
        return typing.cast(typing.List["CategoryStackMapping"], jsii.invoke(self, "filterCategory", [category, service, resource_name]))

    @jsii.member(jsii_name="findResourceForNestedStack")
    def _find_resource_for_nested_stack(
        self,
        category: builtins.str,
        service: builtins.str,
        resource_name: typing.Optional[builtins.str] = None,
    ) -> "CategoryStackMapping":
        '''
        :param category: -
        :param service: -
        :param resource_name: -
        '''
        if __debug__:
            def stub(
                category: builtins.str,
                service: builtins.str,
                resource_name: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
        return typing.cast("CategoryStackMapping", jsii.invoke(self, "findResourceForNestedStack", [category, service, resource_name]))

    @jsii.member(jsii_name="getExportedDataFromFile")
    def _get_exported_data_from_file(self, file_name: builtins.str) -> typing.Any:
        '''
        :param file_name: -
        '''
        if __debug__:
            def stub(file_name: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument file_name", value=file_name, expected_type=type_hints["file_name"])
        return typing.cast(typing.Any, jsii.invoke(self, "getExportedDataFromFile", [file_name]))

    @jsii.member(jsii_name="graphqlNestedStacks")
    def graphql_nested_stacks(self) -> APIGraphQLIncludedNestedStack:
        '''Use this to get the api graphql stack from the backend.

        :return: the nested stack of type {IAPIGraphQLIncludeNestedStack}

        :: true
        :throws: {AmplifyCategoryNotFoundError} if the API graphql stack doesn't exist
        '''
        return typing.cast(APIGraphQLIncludedNestedStack, jsii.invoke(self, "graphqlNestedStacks", []))

    @jsii.member(jsii_name="lambdaFunctionNestedStackByName")
    def lambda_function_nested_stack_by_name(
        self,
        function_name: builtins.str,
    ) -> "LambdaFunctionIncludedNestedStack":
        '''Use this to get a specific lambda function from the backend.

        :param function_name: the function name to get from the nested stack.

        :throws: {AmplifyCategoryNotFoundError} if the lambda function stack doesn't exist
        '''
        if __debug__:
            def stub(function_name: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        return typing.cast("LambdaFunctionIncludedNestedStack", jsii.invoke(self, "lambdaFunctionNestedStackByName", [function_name]))

    @jsii.member(jsii_name="lambdaFunctionNestedStacks")
    def lambda_function_nested_stacks(
        self,
    ) -> typing.List["LambdaFunctionIncludedNestedStack"]:
        '''Use this to get all the lambda functions from the backend.

        :throws: {AmplifyCategoryNotFoundError} if the no Lambda Function stacks are found
        '''
        return typing.cast(typing.List["LambdaFunctionIncludedNestedStack"], jsii.invoke(self, "lambdaFunctionNestedStacks", []))

    @jsii.member(jsii_name="nestedStackByCategortService")
    def nested_stack_by_categort_service(
        self,
        category: builtins.str,
        service: builtins.str,
    ) -> typing.List[aws_cdk.cloudformation_include.IncludedNestedStack]:
        '''
        :param category: -
        :param service: -
        '''
        if __debug__:
            def stub(category: builtins.str, service: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        return typing.cast(typing.List[aws_cdk.cloudformation_include.IncludedNestedStack], jsii.invoke(self, "nestedStackByCategortService", [category, service]))

    @jsii.member(jsii_name="nestedStacksByCategory")
    def nested_stacks_by_category(
        self,
        category: builtins.str,
        resource_name: typing.Optional[builtins.str] = None,
    ) -> typing.List[aws_cdk.cloudformation_include.IncludedNestedStack]:
        '''Returns the stacks defined in the backend.

        :param category: Categories defined in Amplify CLI like function, api, auth etc.
        :param resource_name: -

        :default: is undefined
        '''
        if __debug__:
            def stub(
                category: builtins.str,
                resource_name: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
        return typing.cast(typing.List[aws_cdk.cloudformation_include.IncludedNestedStack], jsii.invoke(self, "nestedStacksByCategory", [category, resource_name]))

    @jsii.member(jsii_name="transformTemplateFile")
    def _transform_template_file(
        self,
        cfn_include_props: typing.Union[aws_cdk.cloudformation_include.CfnIncludeProps, typing.Dict[str, typing.Any]],
        export_path: builtins.str,
    ) -> aws_cdk.cloudformation_include.CfnIncludeProps:
        '''
        :param cfn_include_props: -
        :param export_path: -
        '''
        if __debug__:
            def stub(
                cfn_include_props: typing.Union[aws_cdk.cloudformation_include.CfnIncludeProps, typing.Dict[str, typing.Any]],
                export_path: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cfn_include_props", value=cfn_include_props, expected_type=type_hints["cfn_include_props"])
            check_type(argname="argument export_path", value=export_path, expected_type=type_hints["export_path"])
        return typing.cast(aws_cdk.cloudformation_include.CfnIncludeProps, jsii.invoke(self, "transformTemplateFile", [cfn_include_props, export_path]))

    @builtins.property
    @jsii.member(jsii_name="categoryStackMappings")
    def _category_stack_mappings(self) -> typing.List["CategoryStackMapping"]:
        return typing.cast(typing.List["CategoryStackMapping"], jsii.get(self, "categoryStackMappings"))

    @_category_stack_mappings.setter
    def _category_stack_mappings(
        self,
        value: typing.List["CategoryStackMapping"],
    ) -> None:
        if __debug__:
            def stub(value: typing.List["CategoryStackMapping"]) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "categoryStackMappings", value)

    @builtins.property
    @jsii.member(jsii_name="cfnInclude")
    def cfn_include(self) -> aws_cdk.cloudformation_include.CfnInclude:
        '''cfnInclude of the Amplify backend.'''
        return typing.cast(aws_cdk.cloudformation_include.CfnInclude, jsii.get(self, "cfnInclude"))

    @cfn_include.setter
    def cfn_include(self, value: aws_cdk.cloudformation_include.CfnInclude) -> None:
        if __debug__:
            def stub(value: aws_cdk.cloudformation_include.CfnInclude) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "cfnInclude", value)

    @builtins.property
    @jsii.member(jsii_name="exportBackendManifest")
    def _export_backend_manifest(self) -> "ExportManifest":
        return typing.cast("ExportManifest", jsii.get(self, "exportBackendManifest"))

    @_export_backend_manifest.setter
    def _export_backend_manifest(self, value: "ExportManifest") -> None:
        if __debug__:
            def stub(value: "ExportManifest") -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exportBackendManifest", value)

    @builtins.property
    @jsii.member(jsii_name="exportPath")
    def _export_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "exportPath"))

    @_export_path.setter
    def _export_path(self, value: builtins.str) -> None:
        if __debug__:
            def stub(value: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exportPath", value)

    @builtins.property
    @jsii.member(jsii_name="exportTags")
    def _export_tags(self) -> typing.List["ExportTag"]:
        return typing.cast(typing.List["ExportTag"], jsii.get(self, "exportTags"))

    @_export_tags.setter
    def _export_tags(self, value: typing.List["ExportTag"]) -> None:
        if __debug__:
            def stub(value: typing.List["ExportTag"]) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "exportTags", value)

    @builtins.property
    @jsii.member(jsii_name="rootStack")
    def root_stack(self) -> aws_cdk.Stack:
        '''The root stack created.'''
        return typing.cast(aws_cdk.Stack, jsii.get(self, "rootStack"))

    @root_stack.setter
    def root_stack(self, value: aws_cdk.Stack) -> None:
        if __debug__:
            def stub(value: aws_cdk.Stack) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "rootStack", value)

    @builtins.property
    @jsii.member(jsii_name="auxiliaryDeployment")
    def _auxiliary_deployment(
        self,
    ) -> typing.Optional[aws_cdk.aws_s3_deployment.BucketDeployment]:
        return typing.cast(typing.Optional[aws_cdk.aws_s3_deployment.BucketDeployment], jsii.get(self, "auxiliaryDeployment"))

    @_auxiliary_deployment.setter
    def _auxiliary_deployment(
        self,
        value: typing.Optional[aws_cdk.aws_s3_deployment.BucketDeployment],
    ) -> None:
        if __debug__:
            def stub(
                value: typing.Optional[aws_cdk.aws_s3_deployment.BucketDeployment],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "auxiliaryDeployment", value)

    @builtins.property
    @jsii.member(jsii_name="env")
    def _env(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "env"))

    @_env.setter
    def _env(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            def stub(value: typing.Optional[builtins.str]) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "env", value)


@jsii.data_type(
    jsii_type="@aws-amplify/cdk-exported-backend.AmplifyExportedBackendProps",
    jsii_struct_bases=[aws_cdk.StackProps],
    name_mapping={
        "analytics_reporting": "analyticsReporting",
        "description": "description",
        "env": "env",
        "stack_name": "stackName",
        "synthesizer": "synthesizer",
        "tags": "tags",
        "termination_protection": "terminationProtection",
        "amplify_environment": "amplifyEnvironment",
        "path": "path",
    },
)
class AmplifyExportedBackendProps(aws_cdk.StackProps):
    def __init__(
        self,
        *,
        analytics_reporting: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Union[aws_cdk.Environment, typing.Dict[str, typing.Any]]] = None,
        stack_name: typing.Optional[builtins.str] = None,
        synthesizer: typing.Optional[aws_cdk.IStackSynthesizer] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        termination_protection: typing.Optional[builtins.bool] = None,
        amplify_environment: builtins.str,
        path: builtins.str,
    ) -> None:
        '''
        :param analytics_reporting: Include runtime versioning information in this Stack. Default: ``analyticsReporting`` setting of containing ``App``, or value of 'aws:cdk:version-reporting' context key
        :param description: A description of the stack. Default: - No description.
        :param env: The AWS environment (account/region) where this stack will be deployed. Set the ``region``/``account`` fields of ``env`` to either a concrete value to select the indicated environment (recommended for production stacks), or to the values of environment variables ``CDK_DEFAULT_REGION``/``CDK_DEFAULT_ACCOUNT`` to let the target environment depend on the AWS credentials/configuration that the CDK CLI is executed under (recommended for development stacks). If the ``Stack`` is instantiated inside a ``Stage``, any undefined ``region``/``account`` fields from ``env`` will default to the same field on the encompassing ``Stage``, if configured there. If either ``region`` or ``account`` are not set nor inherited from ``Stage``, the Stack will be considered "*environment-agnostic*"". Environment-agnostic stacks can be deployed to any environment but may not be able to take advantage of all features of the CDK. For example, they will not be able to use environmental context lookups such as ``ec2.Vpc.fromLookup`` and will not automatically translate Service Principals to the right format based on the environment's AWS partition, and other such enhancements. Default: - The environment of the containing ``Stage`` if available, otherwise create the stack will be environment-agnostic.
        :param stack_name: Name to deploy the stack with. Default: - Derived from construct path.
        :param synthesizer: Synthesis method to use while deploying this stack. Default: - ``DefaultStackSynthesizer`` if the ``@aws-cdk/core:newStyleStackSynthesis`` feature flag is set, ``LegacyStackSynthesizer`` otherwise.
        :param tags: Stack tags that will be applied to all the taggable resources and the stack itself. Default: {}
        :param termination_protection: Whether to enable termination protection for this stack. Default: false
        :param amplify_environment: The Amplify CLI environment deploy to The amplify backend requires a stage to deploy. Default: is 'dev'
        :param path: The path to the exported folder that contains the artifacts for the Amplify CLI backend ex: ./amplify-synth-out/.
        '''
        if isinstance(env, dict):
            env = aws_cdk.Environment(**env)
        if __debug__:
            def stub(
                *,
                analytics_reporting: typing.Optional[builtins.bool] = None,
                description: typing.Optional[builtins.str] = None,
                env: typing.Optional[typing.Union[aws_cdk.Environment, typing.Dict[str, typing.Any]]] = None,
                stack_name: typing.Optional[builtins.str] = None,
                synthesizer: typing.Optional[aws_cdk.IStackSynthesizer] = None,
                tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                termination_protection: typing.Optional[builtins.bool] = None,
                amplify_environment: builtins.str,
                path: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument analytics_reporting", value=analytics_reporting, expected_type=type_hints["analytics_reporting"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument stack_name", value=stack_name, expected_type=type_hints["stack_name"])
            check_type(argname="argument synthesizer", value=synthesizer, expected_type=type_hints["synthesizer"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument termination_protection", value=termination_protection, expected_type=type_hints["termination_protection"])
            check_type(argname="argument amplify_environment", value=amplify_environment, expected_type=type_hints["amplify_environment"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        self._values: typing.Dict[str, typing.Any] = {
            "amplify_environment": amplify_environment,
            "path": path,
        }
        if analytics_reporting is not None:
            self._values["analytics_reporting"] = analytics_reporting
        if description is not None:
            self._values["description"] = description
        if env is not None:
            self._values["env"] = env
        if stack_name is not None:
            self._values["stack_name"] = stack_name
        if synthesizer is not None:
            self._values["synthesizer"] = synthesizer
        if tags is not None:
            self._values["tags"] = tags
        if termination_protection is not None:
            self._values["termination_protection"] = termination_protection

    @builtins.property
    def analytics_reporting(self) -> typing.Optional[builtins.bool]:
        '''Include runtime versioning information in this Stack.

        :default:

        ``analyticsReporting`` setting of containing ``App``, or value of
        'aws:cdk:version-reporting' context key
        '''
        result = self._values.get("analytics_reporting")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the stack.

        :default: - No description.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(self) -> typing.Optional[aws_cdk.Environment]:
        '''The AWS environment (account/region) where this stack will be deployed.

        Set the ``region``/``account`` fields of ``env`` to either a concrete value to
        select the indicated environment (recommended for production stacks), or to
        the values of environment variables
        ``CDK_DEFAULT_REGION``/``CDK_DEFAULT_ACCOUNT`` to let the target environment
        depend on the AWS credentials/configuration that the CDK CLI is executed
        under (recommended for development stacks).

        If the ``Stack`` is instantiated inside a ``Stage``, any undefined
        ``region``/``account`` fields from ``env`` will default to the same field on the
        encompassing ``Stage``, if configured there.

        If either ``region`` or ``account`` are not set nor inherited from ``Stage``, the
        Stack will be considered "*environment-agnostic*"". Environment-agnostic
        stacks can be deployed to any environment but may not be able to take
        advantage of all features of the CDK. For example, they will not be able to
        use environmental context lookups such as ``ec2.Vpc.fromLookup`` and will not
        automatically translate Service Principals to the right format based on the
        environment's AWS partition, and other such enhancements.

        :default:

        - The environment of the containing ``Stage`` if available,
        otherwise create the stack will be environment-agnostic.

        Example::

            // Use a concrete account and region to deploy this stack to:
            // `.account` and `.region` will simply return these values.
            new Stack(app, 'Stack1', {
              env: {
                account: '123456789012',
                region: 'us-east-1'
              },
            });
            
            // Use the CLI's current credentials to determine the target environment:
            // `.account` and `.region` will reflect the account+region the CLI
            // is configured to use (based on the user CLI credentials)
            new Stack(app, 'Stack2', {
              env: {
                account: process.env.CDK_DEFAULT_ACCOUNT,
                region: process.env.CDK_DEFAULT_REGION
              },
            });
            
            // Define multiple stacks stage associated with an environment
            const myStage = new Stage(app, 'MyStage', {
              env: {
                account: '123456789012',
                region: 'us-east-1'
              }
            });
            
            // both of these stacks will use the stage's account/region:
            // `.account` and `.region` will resolve to the concrete values as above
            new MyStack(myStage, 'Stack1');
            new YourStack(myStage, 'Stack2');
            
            // Define an environment-agnostic stack:
            // `.account` and `.region` will resolve to `{ "Ref": "AWS::AccountId" }` and `{ "Ref": "AWS::Region" }` respectively.
            // which will only resolve to actual values by CloudFormation during deployment.
            new MyStack(app, 'Stack1');
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[aws_cdk.Environment], result)

    @builtins.property
    def stack_name(self) -> typing.Optional[builtins.str]:
        '''Name to deploy the stack with.

        :default: - Derived from construct path.
        '''
        result = self._values.get("stack_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def synthesizer(self) -> typing.Optional[aws_cdk.IStackSynthesizer]:
        '''Synthesis method to use while deploying this stack.

        :default:

        - ``DefaultStackSynthesizer`` if the ``@aws-cdk/core:newStyleStackSynthesis`` feature flag
        is set, ``LegacyStackSynthesizer`` otherwise.
        '''
        result = self._values.get("synthesizer")
        return typing.cast(typing.Optional[aws_cdk.IStackSynthesizer], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Stack tags that will be applied to all the taggable resources and the stack itself.

        :default: {}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def termination_protection(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable termination protection for this stack.

        :default: false
        '''
        result = self._values.get("termination_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def amplify_environment(self) -> builtins.str:
        '''The Amplify CLI environment deploy to The amplify backend requires a stage to deploy.

        :default: is 'dev'
        '''
        result = self._values.get("amplify_environment")
        assert result is not None, "Required property 'amplify_environment' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''The path to the exported folder that contains the artifacts for the Amplify CLI backend ex: ./amplify-synth-out/.'''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AmplifyExportedBackendProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AuthIncludedNestedStack(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-amplify/cdk-exported-backend.AuthIncludedNestedStack",
):
    def __init__(
        self,
        *,
        included_template: aws_cdk.cloudformation_include.CfnInclude,
        stack: aws_cdk.NestedStack,
    ) -> None:
        '''
        :param included_template: The CfnInclude that represents the template, which can be used to access Resources and other template elements.
        :param stack: The NestedStack object which represents the scope of the template.
        '''
        included_stack = aws_cdk.cloudformation_include.IncludedNestedStack(
            included_template=included_template, stack=stack
        )

        jsii.create(self.__class__, self, [included_stack])

    @jsii.member(jsii_name="getResourceConstruct")
    def get_resource_construct(self, logical_id: builtins.str) -> typing.Any:
        '''
        :param logical_id: -
        '''
        if __debug__:
            def stub(logical_id: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument logical_id", value=logical_id, expected_type=type_hints["logical_id"])
        return typing.cast(typing.Any, jsii.invoke(self, "getResourceConstruct", [logical_id]))

    @jsii.member(jsii_name="hostedUiProviderCredentials")
    def hosted_ui_provider_credentials(
        self,
        credentials: typing.Sequence[typing.Union["ProviderCredential", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param credentials: -
        '''
        if __debug__:
            def stub(
                credentials: typing.Sequence[typing.Union["ProviderCredential", typing.Dict[str, typing.Any]]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        return typing.cast(None, jsii.invoke(self, "hostedUiProviderCredentials", [credentials]))

    @jsii.member(jsii_name="identityPool")
    def identity_pool(self) -> aws_cdk.aws_cognito.CfnIdentityPool:
        '''
        :return: Cognito UserPool {CfnUserPool} of the auth stack

        :throws: {}
        '''
        return typing.cast(aws_cdk.aws_cognito.CfnIdentityPool, jsii.invoke(self, "identityPool", []))

    @jsii.member(jsii_name="userPool")
    def user_pool(self) -> aws_cdk.aws_cognito.CfnUserPool:
        '''
        :return: of the auth stack
        '''
        return typing.cast(aws_cdk.aws_cognito.CfnUserPool, jsii.invoke(self, "userPool", []))

    @builtins.property
    @jsii.member(jsii_name="includedTemplate")
    def included_template(self) -> aws_cdk.cloudformation_include.CfnInclude:
        return typing.cast(aws_cdk.cloudformation_include.CfnInclude, jsii.get(self, "includedTemplate"))

    @included_template.setter
    def included_template(
        self,
        value: aws_cdk.cloudformation_include.CfnInclude,
    ) -> None:
        if __debug__:
            def stub(value: aws_cdk.cloudformation_include.CfnInclude) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "includedTemplate", value)

    @builtins.property
    @jsii.member(jsii_name="stack")
    def stack(self) -> aws_cdk.NestedStack:
        return typing.cast(aws_cdk.NestedStack, jsii.get(self, "stack"))

    @stack.setter
    def stack(self, value: aws_cdk.NestedStack) -> None:
        if __debug__:
            def stub(value: aws_cdk.NestedStack) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stack", value)


@jsii.data_type(
    jsii_type="@aws-amplify/cdk-exported-backend.CategoryStackMapping",
    jsii_struct_bases=[],
    name_mapping={
        "category": "category",
        "resource_name": "resourceName",
        "service": "service",
    },
)
class CategoryStackMapping:
    def __init__(
        self,
        *,
        category: builtins.str,
        resource_name: builtins.str,
        service: builtins.str,
    ) -> None:
        '''
        :param category: 
        :param resource_name: 
        :param service: 
        '''
        if __debug__:
            def stub(
                *,
                category: builtins.str,
                resource_name: builtins.str,
                service: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument resource_name", value=resource_name, expected_type=type_hints["resource_name"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        self._values: typing.Dict[str, typing.Any] = {
            "category": category,
            "resource_name": resource_name,
            "service": service,
        }

    @builtins.property
    def category(self) -> builtins.str:
        result = self._values.get("category")
        assert result is not None, "Required property 'category' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_name(self) -> builtins.str:
        result = self._values.get("resource_name")
        assert result is not None, "Required property 'resource_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> builtins.str:
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CategoryStackMapping(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-amplify/cdk-exported-backend.ExportManifest",
    jsii_struct_bases=[],
    name_mapping={"props": "props", "stack_name": "stackName"},
)
class ExportManifest:
    def __init__(
        self,
        *,
        props: typing.Union[aws_cdk.cloudformation_include.CfnIncludeProps, typing.Dict[str, typing.Any]],
        stack_name: builtins.str,
    ) -> None:
        '''
        :param props: 
        :param stack_name: 
        '''
        if isinstance(props, dict):
            props = aws_cdk.cloudformation_include.CfnIncludeProps(**props)
        if __debug__:
            def stub(
                *,
                props: typing.Union[aws_cdk.cloudformation_include.CfnIncludeProps, typing.Dict[str, typing.Any]],
                stack_name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument stack_name", value=stack_name, expected_type=type_hints["stack_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "props": props,
            "stack_name": stack_name,
        }

    @builtins.property
    def props(self) -> aws_cdk.cloudformation_include.CfnIncludeProps:
        result = self._values.get("props")
        assert result is not None, "Required property 'props' is missing"
        return typing.cast(aws_cdk.cloudformation_include.CfnIncludeProps, result)

    @builtins.property
    def stack_name(self) -> builtins.str:
        result = self._values.get("stack_name")
        assert result is not None, "Required property 'stack_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExportManifest(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@aws-amplify/cdk-exported-backend.ExportTag",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "value": "value"},
)
class ExportTag:
    def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
        '''
        :param key: 
        :param value: 
        '''
        if __debug__:
            def stub(*, key: builtins.str, value: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "value": value,
        }

    @builtins.property
    def key(self) -> builtins.str:
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExportTag(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaFunctionIncludedNestedStack(
    metaclass=jsii.JSIIMeta,
    jsii_type="@aws-amplify/cdk-exported-backend.LambdaFunctionIncludedNestedStack",
):
    def __init__(
        self,
        *,
        included_template: aws_cdk.cloudformation_include.CfnInclude,
        stack: aws_cdk.NestedStack,
    ) -> None:
        '''
        :param included_template: The CfnInclude that represents the template, which can be used to access Resources and other template elements.
        :param stack: The NestedStack object which represents the scope of the template.
        '''
        included_stack = aws_cdk.cloudformation_include.IncludedNestedStack(
            included_template=included_template, stack=stack
        )

        jsii.create(self.__class__, self, [included_stack])

    @jsii.member(jsii_name="getResourceConstruct")
    def get_resource_construct(self, logical_id: builtins.str) -> typing.Any:
        '''
        :param logical_id: -
        '''
        if __debug__:
            def stub(logical_id: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument logical_id", value=logical_id, expected_type=type_hints["logical_id"])
        return typing.cast(typing.Any, jsii.invoke(self, "getResourceConstruct", [logical_id]))

    @jsii.member(jsii_name="lambdaFunction")
    def lambda_function(self) -> aws_cdk.aws_lambda.CfnFunction:
        return typing.cast(aws_cdk.aws_lambda.CfnFunction, jsii.invoke(self, "lambdaFunction", []))

    @builtins.property
    @jsii.member(jsii_name="includedTemplate")
    def included_template(self) -> aws_cdk.cloudformation_include.CfnInclude:
        return typing.cast(aws_cdk.cloudformation_include.CfnInclude, jsii.get(self, "includedTemplate"))

    @included_template.setter
    def included_template(
        self,
        value: aws_cdk.cloudformation_include.CfnInclude,
    ) -> None:
        if __debug__:
            def stub(value: aws_cdk.cloudformation_include.CfnInclude) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "includedTemplate", value)

    @builtins.property
    @jsii.member(jsii_name="stack")
    def stack(self) -> aws_cdk.NestedStack:
        return typing.cast(aws_cdk.NestedStack, jsii.get(self, "stack"))

    @stack.setter
    def stack(self, value: aws_cdk.NestedStack) -> None:
        if __debug__:
            def stub(value: aws_cdk.NestedStack) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "stack", value)


@jsii.data_type(
    jsii_type="@aws-amplify/cdk-exported-backend.ProviderCredential",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "provider_name": "providerName",
    },
)
class ProviderCredential:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        client_secret: builtins.str,
        provider_name: builtins.str,
    ) -> None:
        '''
        :param client_id: 
        :param client_secret: 
        :param provider_name: 
        '''
        if __debug__:
            def stub(
                *,
                client_id: builtins.str,
                client_secret: builtins.str,
                provider_name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument provider_name", value=provider_name, expected_type=type_hints["provider_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
            "provider_name": provider_name,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret(self) -> builtins.str:
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def provider_name(self) -> builtins.str:
        result = self._values.get("provider_name")
        assert result is not None, "Required property 'provider_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ProviderCredential(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "APIGraphQLIncludedNestedStack",
    "APIRestIncludedStack",
    "AmplifyExportedBackend",
    "AmplifyExportedBackendProps",
    "AuthIncludedNestedStack",
    "CategoryStackMapping",
    "ExportManifest",
    "ExportTag",
    "LambdaFunctionIncludedNestedStack",
    "ProviderCredential",
]

publication.publish()
