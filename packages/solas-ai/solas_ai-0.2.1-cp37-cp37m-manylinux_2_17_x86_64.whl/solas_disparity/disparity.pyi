import numpy as np
import pandas as pd
from . import const as const, statistical_significance as statistical_significance
from .types import Disparity as Disparity, DisparityCalculation as DisparityCalculation, ResidualSMDDenominator as ResidualSMDDenominator, SMDDenominator as SMDDenominator, StatSig as StatSig, StatSigHypothesis as StatSigHypothesis, StatSigTest as StatSigTest
from solas_disparity.conditioning import condition as condition
from solas_disparity.utils import pgrg_ordered as pgrg_ordered
from solas_disparity.validation import validation as validation
from typing import List, Optional, Union

def adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ...) -> Disparity: ...
def adverse_impact_ratio_by_quantile(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, quantiles: Union[pd.Series, np.ndarray, List[float]], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ..., lower_score_favorable: bool = ..., merge_bins: bool = ...) -> Disparity: ...
def categorical_adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, ordinal_categories: Union[pd.Series, np.ndarray, List], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ...) -> Disparity: ...
def odds_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], odds_ratio_threshold: float, percent_difference_threshold: float, lower_score_favorable: bool = ..., label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ...) -> Disparity: ...
def standardized_mean_difference(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], smd_threshold: float, lower_score_favorable: bool = ..., label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., smd_denominator: Union[str, SMDDenominator] = ...) -> Disparity: ...
def residual_standardized_mean_difference(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], prediction: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], residual_smd_threshold: float, lower_score_favorable: bool = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., residual_smd_denominator: Optional[Union[str, ResidualSMDDenominator]] = ...): ...
def segmented_adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, fdr_threshold: float, segment: Union[pd.Series, np.ndarray, pd.DataFrame], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ..., shift_zeros: bool = ..., overwrite_segment_results: bool = ...) -> Disparity: ...
